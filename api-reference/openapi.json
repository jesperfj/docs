{"openapi":"3.0.3","info":{"title":"ConfigHub API","description":"ConfigHub API","termsOfService":"TBD","contact":{"name":"ConfigHub Support","url":"https://confighub.com/","email":"hello@confighub.com"},"license":{"name":"N/A","url":"https://confighub.com/TBD"},"version":"0.1.0"},"servers":[{"url":"https://hub.confighub.com/api","description":"production"},{"url":"http://localhost:9090/api","description":"local"}],"security":[{"bearerAuth":[]}],"paths":{"/_space":{"delete":{"tags":["Space"],"summary":"Bulk delete multiple spaces","description":"Delete multiple spaces selected by query parameters","operationId":"BulkDeleteSpaces","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Space include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Space are OrganizationID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"recursive","in":"query","description":"Valid values are true and false. False is the default if unspecified. If true, recursively delete all entities within the deleted space(s).","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Space"],"summary":"Bulk patch multiple spaces","description":"Apply JSON merge patch to multiple spaces selected by query parameters","operationId":"BulkPatchSpaces","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Space include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Space are OrganizationID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"WhereTrigger":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Space. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Space"],"summary":"Bulk create (clone) multiple spaces","description":"Clone multiple spaces selected by query parameters with optional name prefixes","operationId":"BulkCreateSpaces","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Space include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Space are OrganizationID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Space names","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"WhereTrigger":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Space. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SpaceCreateOrUpdateResponse"}}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/bridge_worker":{"delete":{"tags":["BridgeWorker"],"summary":"Bulk delete multiple bridge workers","description":"Delete multiple bridge workers selected by query parameters","operationId":"BulkDeleteBridgeWorkers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of BridgeWorkers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the BridgeWorker list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (BridgeWorker).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for BridgeWorker are OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"BridgeWorker could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["BridgeWorker"],"summary":"List all BridgeWorker across spaces","description":"List all BridgeWorker across spaces","operationId":"ListAllBridgeWorkers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of BridgeWorkers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for BridgeWorker are OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"summary","in":"query","description":"Include summary information in the response","required":false,"schema":{"type":"boolean"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}}}}},"patch":{"tags":["BridgeWorker"],"summary":"Bulk patch multiple bridge workers","description":"Apply JSON merge patch to multiple bridge workers selected by query parameters","operationId":"BulkPatchBridgeWorkers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of BridgeWorkers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the BridgeWorker list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (BridgeWorker).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for BridgeWorker are OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Condition":{"type":"string","description":"","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for BridgeWorker. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BridgeWorkerCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BridgeWorkerCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BridgeWorkerCreateOrUpdateResponse"}}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/bridge_worker/{bridge_worker_id}/action_result":{"post":{"tags":["BridgeWorker"],"summary":"Create action result","description":"Records the status/result of an action executed by a bridge worker","operationId":"CreateActionResult","parameters":[{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ActionResult"}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"string"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/bridge_worker/{bridge_worker_id}/me":{"get":{"tags":["BridgeWorker"],"summary":"Gets the current BridgeWorker from context","description":"Gets the current BridgeWorker from context","operationId":"GetSelf","parameters":[{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"200":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/bridge_worker/{bridge_worker_id}/stream":{"post":{"tags":["BridgeWorker"],"summary":"Stream events to bridge worker","description":"Establishes an SSE connection with a bridge worker for real-time event streaming","operationId":"StreamBridgeWorker","parameters":[{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"text/event-stream":{"schema":{"$ref":"#/components/schemas/EventMessage"}}}},"200":{"description":"OK","content":{"text/event-stream":{"schema":{"$ref":"#/components/schemas/EventMessage"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/change_set":{"delete":{"tags":["ChangeSet"],"summary":"Bulk delete multiple changesets","description":"Delete multiple changesets selected by query parameters","operationId":"BulkDeleteChangeSets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of ChangeSets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, DeleteGates, Description, DisplayName, EndTagID, Labels, OrganizationID, Slug, SpaceID, StartTagID, State, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the ChangeSet list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (ChangeSet).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["ChangeSet"],"summary":"List of ChangeSets across spaces","description":"Retrieves a list of ChangeSets across spaces in the Organization","operationId":"ListAllChangeSets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of ChangeSets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, DeleteGates, Description, DisplayName, EndTagID, Labels, OrganizationID, Slug, SpaceID, StartTagID, State, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the ChangeSet list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (ChangeSet).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["ChangeSet"],"summary":"Bulk patch multiple changesets","description":"Apply JSON merge patch to multiple changesets selected by query parameters","operationId":"BulkPatchChangeSets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of ChangeSets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, DeleteGates, Description, DisplayName, EndTagID, Labels, OrganizationID, Slug, SpaceID, StartTagID, State, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the ChangeSet list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (ChangeSet).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Description":{"type":"string","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for ChangeSet. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["ChangeSet"],"summary":"Bulk create (clone) multiple changesets","description":"Clone multiple changesets selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateChangeSets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of ChangeSets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, DeleteGates, Description, DisplayName, EndTagID, Labels, OrganizationID, Slug, SpaceID, StartTagID, State, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the ChangeSet list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (ChangeSet).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned ChangeSet names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning changesets\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Description":{"type":"string","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for ChangeSet. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ChangeSetCreateOrUpdateResponse"}}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/filter":{"delete":{"tags":["Filter"],"summary":"Bulk delete multiple filters","description":"Delete multiple filters selected by query parameters","operationId":"BulkDeleteFilters","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Filters returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Filter: CreatedAt, DeleteGates, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Filter list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Filter).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Filter include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Filter"],"summary":"List of Filters across spaces","description":"Retrieves a list of Filters across spaces in the Organization","operationId":"ListAllFilters","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Filters returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Filter: CreatedAt, DeleteGates, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Filter list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Filter).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Filter include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"entity","in":"query","description":"Entity type to filter for (e.g., Unit, Space). Must be specified together with 'id' parameter.","required":false,"schema":{"type":"string"}},{"name":"id","in":"query","description":"Entity ID to filter for. Must be specified together with 'entity' parameter.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedFilter"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedFilter"}}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Filter"],"summary":"Bulk patch multiple filters","description":"Apply JSON merge patch to multiple filters selected by query parameters","operationId":"BulkPatchFilters","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Filters returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Filter: CreatedAt, DeleteGates, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Filter list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Filter).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Filter include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"From":{"type":"string","description":"","nullable":true},"FromSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"ResourceType":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"Where":{"type":"string","description":"","nullable":true},"WhereData":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Filter. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Filter"],"summary":"Bulk create (clone) multiple filters","description":"Clone multiple filters selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateFilters","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Filters returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Filter: CreatedAt, DeleteGates, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Filter list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Filter).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Filter include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Filter names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning filters\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"From":{"type":"string","description":"","nullable":true},"FromSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"ResourceType":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"Where":{"type":"string","description":"","nullable":true},"WhereData":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Filter. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FilterCreateOrUpdateResponse"}}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/function":{"get":{"tags":["Function"],"summary":"List retrieves a map of Functions across the Organization","description":"List retrieves a map of Functions across the Organization","operationId":"ListOrgFunctions","responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}},"400":{"description":"Function request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Function not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Function.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/function/invoke":{"post":{"tags":["Function"],"summary":"Invoke Functions across Org","description":"Invoke Functions across Units in the Organization","operationId":"InvokeFunctionsOnOrg","parameters":[{"name":"dry_run","in":"query","description":"Dry run mode: when true, skip updating configuration data even if it changed","required":false,"schema":{"type":"string"}},{"name":"change_set_id","in":"query","description":"Must match ChangeSetID of affected Units unless in dry run mode; not valid when invoked on Revisions","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/FunctionInvocationsRequest"}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"400":{"description":"Function request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Function not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to process configuration data","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Function.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/invocation":{"delete":{"tags":["Invocation"],"summary":"Bulk delete multiple invocations","description":"Delete multiple invocations selected by query parameters","operationId":"BulkDeleteInvocations","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Invocations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Invocation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Invocation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Invocation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Invocation"],"summary":"List of Invocations across spaces","description":"Retrieves a list of Invocations across spaces in the Organization","operationId":"ListAllInvocations","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Invocations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Invocation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Invocation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Invocation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedInvocation"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedInvocation"}}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Invocation"],"summary":"Bulk patch multiple invocations","description":"Apply JSON merge patch to multiple invocations selected by query parameters","operationId":"BulkPatchInvocations","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Invocations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Invocation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Invocation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Invocation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Invocation. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Invocation"],"summary":"Bulk create (clone) multiple invocations","description":"Clone multiple invocations selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateInvocations","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Invocations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Invocation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Invocation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Invocation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Invocation names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning invocations\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Invocation. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InvocationCreateOrUpdateResponse"}}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/link":{"delete":{"tags":["Link"],"summary":"Delete multiple Links","description":"Deletes multiple Links based on search criteria","operationId":"BulkDeleteLinks","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Links returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Link: CreatedAt, DeleteGates, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.\n\nfilter\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Link list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Link).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Link include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Link"],"summary":"List of Links across spaces","description":"Retrieves a list of Links across spaces in the Organization","operationId":"SearchListLinks","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Links returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Link: CreatedAt, DeleteGates, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Link list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Link).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Link include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedLink"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedLink"}}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Link"],"summary":"Update multiple Links","description":"Updates multiple Links based on search criteria","operationId":"BulkPatchLinks","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Links returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Link: CreatedAt, DeleteGates, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.\n\nfilter\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Link list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Link).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Link include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FromUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"ToUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Link. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Link"],"summary":"Bulk create (clone) multiple links","description":"Clone multiple links selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateLinks","parameters":[{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for created links\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"where_to_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select ToSpaces for created links\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_to_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"where_from","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nWhere expression to select FromUnits for created links\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_from","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"where_to","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nWhere expression to select ToUnits for created links\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_to","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FromUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"ToUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Link. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"}}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/me":{"get":{"tags":["UserInfo"],"summary":"Get the current user's information","description":"Get the current user's information","operationId":"GetMe","responses":{"default":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"200":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"400":{"description":"UserInfo request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"UserInfo not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing UserInfo.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/organization":{"get":{"tags":["Organization"],"summary":"List Organizations","description":"List Organizations","operationId":"ListOrganizations","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Organizations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Organization: BillingAccountID, CreatedAt, DeleteGates, DisplayName, ExternalID, Labels, OrganizationID, Slug, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Organization list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Organization).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Organization include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Organization.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Organization are .\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Organization.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, OrganizationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/Organization"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/Organization"}}}}},"400":{"description":"Organization request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Organization not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Organization.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Organization"],"summary":"Create Organization","description":"Create Organization","operationId":"CreateOrganization","parameters":[{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"responses":{"default":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"200":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"400":{"description":"Organization request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Organization not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Organization.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/organization/{organization_id}":{"delete":{"tags":["Organization"],"summary":"Delete Organization","description":"Delete Organization","operationId":"DeleteOrganization","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Organization request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Organization not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Organization could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Organization.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Organization"],"summary":"Get Organization","description":"Get Organization","operationId":"GetOrganization","parameters":[{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Organization.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Organization are .\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Organization.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, OrganizationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"200":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"400":{"description":"Organization request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Organization not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Organization.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Organization"],"summary":"Update Organization","description":"Update Organization","operationId":"UpdateOrganization","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"responses":{"default":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"200":{"description":"The top-level container for an organization using ConfigHub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Organization"}}}},"400":{"description":"Organization request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Organization not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Organization data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Organization.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/organization/{organization_id}/organization_member":{"get":{"tags":["OrganizationMember"],"summary":"List OrganizationMembers","description":"List OrganizationMembers","operationId":"ListOrganizationMembers","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of OrganizationMembers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on OrganizationMember: DisplayName, ExternalID, Slug, UserID, Username.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the OrganizationMember list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (OrganizationMember).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for OrganizationMember include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/OrganizationMember"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/OrganizationMember"}}}}},"400":{"description":"OrganizationMember request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"OrganizationMember not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing OrganizationMember.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["OrganizationMember"],"summary":"Create OrganizationMember","description":"Create OrganizationMember","operationId":"CreateOrganizationMember","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"responses":{"default":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"200":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"400":{"description":"OrganizationMember request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"OrganizationMember not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing OrganizationMember.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/organization/{organization_id}/organization_member/{organization_member_id}":{"delete":{"tags":["OrganizationMember"],"summary":"Delete OrganizationMember","description":"Delete OrganizationMember","operationId":"DeleteOrganizationMember","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"organization_member_id","in":"path","description":"Unique identifier for a organization_member_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"OrganizationMember request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"OrganizationMember not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"OrganizationMember could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing OrganizationMember.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["OrganizationMember"],"summary":"Get OrganizationMember","description":"Get OrganizationMember","operationId":"GetOrganizationMember","parameters":[{"name":"organization_id","in":"path","description":"Unique identifier for a organization_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"organization_member_id","in":"path","description":"Unique identifier for a organization_member_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"200":{"description":"a User given membership on the Organization","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrganizationMember"}}}},"400":{"description":"OrganizationMember request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"OrganizationMember not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing OrganizationMember.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/revision":{"get":{"tags":["Revision"],"summary":"List of Revisions across spaces","description":"Retrieves a list of Revisions across spaces in the Organization, returning at most one revision per unit","operationId":"ListAllRevisions","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Revisions returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Revision: ApplyGates, ApprovedBy, ChangeSetID, CreatedAt, Description, LiveAt, OrganizationID, RevisionID, RevisionNum, Source, SpaceID, Tags, UnitID, UpdatedAt, UserAgent, UserID.\n\nTo list tagged Revisions use `Tags ? '\u003ctag-id\u003e'`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Revision list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Revision).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Revision include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Revision are ChangeSetID, OrganizationID, SpaceID, Tags, UnitID, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, RevisionID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedRevision"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedRevision"}}}}},"400":{"description":"Revision request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Revision not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Revision.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space":{"get":{"tags":["Space"],"summary":"List Spaces","description":"List Spaces","operationId":"ListSpaces","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Space include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Space are OrganizationID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, SpaceID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"summary","in":"query","description":"Flag parameter for enabling summary","required":false,"schema":{"type":"boolean"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedSpace"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedSpace"}}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Space"],"summary":"Create Space","description":"Create Space","operationId":"CreateSpace","parameters":[{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"responses":{"default":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"200":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}":{"delete":{"tags":["Space"],"summary":"Delete Space","description":"Delete Space","operationId":"DeleteSpace","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"recursive","in":"query","description":"Valid values are true and false. False is the default if unspecified. If true, recursively delete all entities within the deleted space(s).","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Space could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Space"],"summary":"Get Space","description":"Get Space","operationId":"GetSpace","parameters":[{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Space are OrganizationID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Space.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, SpaceID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"summary","in":"query","description":"Flag parameter for enabling summary","required":false,"schema":{"type":"boolean"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedSpace"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedSpace"}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Space"],"summary":"Patch Space","description":"Patch Space","operationId":"PatchSpace","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"WhereTrigger":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Space. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"200":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Space"],"summary":"Update Space","description":"Update Space","operationId":"UpdateSpace","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"responses":{"default":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"200":{"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Space"}}}},"400":{"description":"Space request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Space not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Space data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Space.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/bridge_worker":{"get":{"tags":["BridgeWorker"],"summary":"List BridgeWorkers","description":"List BridgeWorkers","operationId":"ListBridgeWorkers","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of BridgeWorkers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the BridgeWorker list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (BridgeWorker).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for BridgeWorker are OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["BridgeWorker"],"summary":"Create BridgeWorker","description":"Create BridgeWorker","operationId":"CreateBridgeWorker","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"responses":{"default":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"200":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/bridge_worker/{bridge_worker_id}":{"delete":{"tags":["BridgeWorker"],"summary":"Delete BridgeWorker","description":"Delete BridgeWorker","operationId":"DeleteBridgeWorker","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"BridgeWorker could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["BridgeWorker"],"summary":"Get BridgeWorker","description":"Get BridgeWorker","operationId":"GetBridgeWorker","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for BridgeWorker are OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for BridgeWorker.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedBridgeWorker"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["BridgeWorker"],"summary":"Patch BridgeWorker","description":"Patch BridgeWorker","operationId":"PatchBridgeWorker","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Condition":{"type":"string","description":"","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for BridgeWorker. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"200":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["BridgeWorker"],"summary":"Update BridgeWorker","description":"Update BridgeWorker","operationId":"UpdateBridgeWorker","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"responses":{"default":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"200":{"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorker"}}}},"400":{"description":"BridgeWorker request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorker not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"BridgeWorker data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/bridge_worker/{bridge_worker_id}/function":{"get":{"tags":["BridgeWorker"],"summary":"List available functions supported by a specific bridge worker","description":"List available functions supported by a specific bridge worker","operationId":"ListBridgeWorkerFunctions","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}}}}},"/space/{space_id}/bridge_worker/{bridge_worker_id}/status":{"get":{"tags":["BridgeWorkerStatus"],"summary":"List BridgeWorkerStatuses","description":"List BridgeWorkerStatuses","operationId":"ListBridgeWorkerStatuses","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BridgeWorkerStatus"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BridgeWorkerStatus"}}}}},"400":{"description":"BridgeWorkerStatus request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorkerStatus not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorkerStatus.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/bridge_worker/{bridge_worker_id}/status/{status_id}":{"get":{"tags":["BridgeWorkerStatus"],"summary":"Get BridgeWorkerStatus","description":"Get BridgeWorkerStatus","operationId":"GetBridgeWorkerStatus","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"bridge_worker_id","in":"path","description":"Unique identifier for a bridge_worker_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"status_id","in":"path","description":"Unique identifier for a status_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"BridgeWorkerStatus represents the status information of a bridge worker within the system.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorkerStatus"}}}},"200":{"description":"BridgeWorkerStatus represents the status information of a bridge worker within the system.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BridgeWorkerStatus"}}}},"400":{"description":"BridgeWorkerStatus request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"BridgeWorkerStatus not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing BridgeWorkerStatus.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/change_set":{"get":{"tags":["ChangeSet"],"summary":"List ChangeSets","description":"List ChangeSets","operationId":"ListChangeSets","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of ChangeSets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, DeleteGates, Description, DisplayName, EndTagID, Labels, OrganizationID, Slug, SpaceID, StartTagID, State, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the ChangeSet list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (ChangeSet).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["ChangeSet"],"summary":"Create ChangeSet","description":"Create ChangeSet","operationId":"CreateChangeSet","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"responses":{"default":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"200":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/change_set/{change_set_id}":{"delete":{"tags":["ChangeSet"],"summary":"Delete ChangeSet","description":"Delete ChangeSet","operationId":"DeleteChangeSet","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"path","description":"Unique identifier for a change_set_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"ChangeSet could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["ChangeSet"],"summary":"Get ChangeSet","description":"Get ChangeSet","operationId":"GetChangeSet","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for ChangeSet are EndTagID, OrganizationID, SpaceID, StartTagID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for ChangeSet.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"change_set_id","in":"path","description":"Unique identifier for a change_set_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedChangeSet"}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["ChangeSet"],"summary":"Patch ChangeSet","description":"Patch ChangeSet","operationId":"PatchChangeSet","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"path","description":"Unique identifier for a change_set_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Description":{"type":"string","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for ChangeSet. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"200":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["ChangeSet"],"summary":"Update ChangeSet","description":"Update ChangeSet","operationId":"UpdateChangeSet","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"path","description":"Unique identifier for a change_set_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"responses":{"default":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"200":{"description":"Defines an entity changeset.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ChangeSet"}}}},"400":{"description":"ChangeSet request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ChangeSet not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"ChangeSet data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ChangeSet.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/filter":{"get":{"tags":["Filter"],"summary":"List Filters","description":"List Filters","operationId":"ListFilters","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Filters returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Filter: CreatedAt, DeleteGates, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Filter list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Filter).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Filter include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"entity","in":"query","description":"Entity type to filter for (e.g., Unit, Space). Must be specified together with 'id' parameter.","required":false,"schema":{"type":"string"}},{"name":"id","in":"query","description":"Entity ID to filter for. Must be specified together with 'entity' parameter.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedFilter"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedFilter"}}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Filter"],"summary":"Create Filter","description":"Create Filter","operationId":"CreateFilter","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"responses":{"default":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"200":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/filter/{filter_id}":{"delete":{"tags":["Filter"],"summary":"Delete Filter","description":"Delete Filter","operationId":"DeleteFilter","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"filter_id","in":"path","description":"Unique identifier for a filter_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Filter could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Filter"],"summary":"Get Filter","description":"Get Filter","operationId":"GetFilter","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Filter.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_id","in":"path","description":"Unique identifier for a filter_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedFilter"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedFilter"}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Filter"],"summary":"Patch Filter","description":"Patch Filter","operationId":"PatchFilter","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"filter_id","in":"path","description":"Unique identifier for a filter_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"From":{"type":"string","description":"","nullable":true},"FromSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"ResourceType":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true},"Where":{"type":"string","description":"","nullable":true},"WhereData":{"type":"string","description":"","nullable":true}},"description":"JSON Merge Patch schema for Filter. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"200":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Filter"],"summary":"Update Filter","description":"Update Filter","operationId":"UpdateFilter","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"filter_id","in":"path","description":"Unique identifier for a filter_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"responses":{"default":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"200":{"description":"Defines an entity filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Filter"}}}},"400":{"description":"Filter request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Filter not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Filter data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Filter.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/function":{"get":{"tags":["Function"],"summary":"List retrieves a map of Functions","description":"List retrieves a map of Functions","operationId":"ListFunctions","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"entity","in":"query","description":"Type of entity used to identify the worker whose functions should be listed: unit, target, or worker","required":false,"schema":{"type":"string"}},{"name":"id","in":"query","description":"ID of the entity used to identify the worker whose functions should be listed","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}}}}}},"400":{"description":"Function request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Function not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Function.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/function/invoke":{"post":{"tags":["Function"],"summary":"Invoke Functions","description":"Invoke Functions","operationId":"InvokeFunctions","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"query","description":"Unit ID of the Revision to invoke functions on","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"revision_id","in":"query","description":"Revision ID to invoke functions on instead of units","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"dry_run","in":"query","description":"Dry run mode: when true, skip updating configuration data even if it changed","required":false,"schema":{"type":"string"}},{"name":"change_set_id","in":"query","description":"Must match ChangeSetID of affected Units unless in dry run mode; not valid when invoked on Revisions","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/FunctionInvocationsRequest"}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocationsResponse"}}}}},"400":{"description":"Function request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Function not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to process configuration data","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Function.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/invocation":{"get":{"tags":["Invocation"],"summary":"List Invocations","description":"List Invocations","operationId":"ListInvocations","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Invocations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Invocation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Invocation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Invocation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedInvocation"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedInvocation"}}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Invocation"],"summary":"Create Invocation","description":"Create Invocation","operationId":"CreateInvocation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"responses":{"default":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"200":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/invocation/{invocation_id}":{"delete":{"tags":["Invocation"],"summary":"Delete Invocation","description":"Delete Invocation","operationId":"DeleteInvocation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"invocation_id","in":"path","description":"Unique identifier for a invocation_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Invocation could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Invocation"],"summary":"Get Invocation","description":"Get Invocation","operationId":"GetInvocation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Invocation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"invocation_id","in":"path","description":"Unique identifier for a invocation_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedInvocation"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedInvocation"}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Invocation"],"summary":"Patch Invocation","description":"Patch Invocation","operationId":"PatchInvocation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"invocation_id","in":"path","description":"Unique identifier for a invocation_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Invocation. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"200":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Invocation"],"summary":"Update Invocation","description":"Update Invocation","operationId":"UpdateInvocation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"invocation_id","in":"path","description":"Unique identifier for a invocation_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"responses":{"default":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"200":{"description":"Defines a function invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Invocation"}}}},"400":{"description":"Invocation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Invocation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Invocation data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Invocation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/link":{"get":{"tags":["Link"],"summary":"List Links","description":"List Links","operationId":"ListLinks","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Links returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Link: CreatedAt, DeleteGates, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Link list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Link).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Link include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedLink"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedLink"}}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Link"],"summary":"Create Link","description":"Create Link","operationId":"CreateLink","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"responses":{"default":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"200":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/link/{link_id}":{"delete":{"tags":["Link"],"summary":"Delete Link","description":"Delete Link","operationId":"DeleteLink","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"link_id","in":"path","description":"Unique identifier for a link_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Link could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Link"],"summary":"Get Link","description":"Get Link","operationId":"GetLink","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Link.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"link_id","in":"path","description":"Unique identifier for a link_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedLink"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedLink"}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Link"],"summary":"Patch Link","description":"Patch Link","operationId":"PatchLink","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"link_id","in":"path","description":"Unique identifier for a link_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FromUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToSpaceID":{"type":"string","description":"","format":"uuid","nullable":true},"ToUnitID":{"type":"string","description":"","format":"uuid","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Link. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"200":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Link"],"summary":"Update Link","description":"Update Link","operationId":"UpdateLink","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"link_id","in":"path","description":"Unique identifier for a link_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"responses":{"default":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"200":{"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Link"}}}},"400":{"description":"Link request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Link not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Link data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Link.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/tag":{"get":{"tags":["Tag"],"summary":"List Tags","description":"List Tags","operationId":"ListTags","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Tags returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Tag: ChangeSetID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Tag list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Tag).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Tag include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTag"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTag"}}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Tag"],"summary":"Create Tag","description":"Create Tag","operationId":"CreateTag","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"responses":{"default":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"200":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/tag/{tag_id}":{"delete":{"tags":["Tag"],"summary":"Delete Tag","description":"Delete Tag","operationId":"DeleteTag","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"tag_id","in":"path","description":"Unique identifier for a tag_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Tag could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Tag"],"summary":"Get Tag","description":"Get Tag","operationId":"GetTag","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"tag_id","in":"path","description":"Unique identifier for a tag_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTag"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTag"}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Tag"],"summary":"Patch Tag","description":"Patch Tag","operationId":"PatchTag","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"tag_id","in":"path","description":"Unique identifier for a tag_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Tag. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"200":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Tag"],"summary":"Update Tag","description":"Update Tag","operationId":"UpdateTag","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"tag_id","in":"path","description":"Unique identifier for a tag_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"responses":{"default":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"200":{"description":"Defines a Tag that can be used to identify a set of Revisions across Units.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Tag"}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Tag data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/target":{"get":{"tags":["Target"],"summary":"List Targets","description":"List Targets","operationId":"ListTargets","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Targets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Target list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Target).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Target include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTarget"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTarget"}}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Target"],"summary":"Create Target","description":"Create Target","operationId":"CreateTarget","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"responses":{"default":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"200":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/target/{target_id}":{"delete":{"tags":["Target"],"summary":"Delete Target","description":"Delete Target","operationId":"DeleteTarget","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"target_id","in":"path","description":"Unique identifier for a target_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Target could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Target"],"summary":"Get Target","description":"Get Target","operationId":"GetTarget","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"target_id","in":"path","description":"Unique identifier for a target_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTarget"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTarget"}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Target"],"summary":"Patch Target","description":"Patch Target","operationId":"PatchTarget","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"target_id","in":"path","description":"Unique identifier for a target_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Parameters":{"type":"string","description":"","nullable":true},"ProviderType":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Target. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"200":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Target"],"summary":"Update Target","description":"Update Target","operationId":"UpdateTarget","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"target_id","in":"path","description":"Unique identifier for a target_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"responses":{"default":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"200":{"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Target"}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Target data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/trigger":{"get":{"tags":["Trigger"],"summary":"List Triggers","description":"List Triggers","operationId":"ListTriggers","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Trigger list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Trigger).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Trigger include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTrigger"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTrigger"}}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Trigger"],"summary":"Create Trigger","description":"Create Trigger","operationId":"CreateTrigger","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"responses":{"default":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"200":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/trigger/{trigger_id}":{"delete":{"tags":["Trigger"],"summary":"Delete Trigger","description":"Delete Trigger","operationId":"DeleteTrigger","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"trigger_id","in":"path","description":"Unique identifier for a trigger_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Trigger could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Trigger"],"summary":"Get Trigger","description":"Get Trigger","operationId":"GetTrigger","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"trigger_id","in":"path","description":"Unique identifier for a trigger_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTrigger"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedTrigger"}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Trigger"],"summary":"Patch Trigger","description":"Patch Trigger","operationId":"PatchTrigger","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"trigger_id","in":"path","description":"Unique identifier for a trigger_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Disabled":{"type":"boolean","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Enforced":{"type":"boolean","description":"","nullable":true},"Event":{"type":"string","description":"","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"InvocationID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Trigger. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"200":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Trigger"],"summary":"Update Trigger","description":"Update Trigger","operationId":"UpdateTrigger","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"trigger_id","in":"path","description":"Unique identifier for a trigger_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"responses":{"default":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"200":{"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Trigger"}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Trigger data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit":{"get":{"tags":["Unit"],"summary":"List Units","description":"List Units","operationId":"ListUnits","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Unit"],"summary":"Create Unit","description":"Create Unit","operationId":"CreateUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"upstream_space_id","in":"query","description":"Unique identifier for a upstream_space_id","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"upstream_unit_id","in":"query","description":"Unique identifier for a upstream_unit_id","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"responses":{"default":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"200":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to create unit(s) due to configuration data problem","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/extended":{"get":{"tags":["Unit"],"summary":"List of Units in the space with optional expanded relationships","description":"List of Units in the space with optional expanded relationships","operationId":"ListExtendedUnits","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}":{"delete":{"tags":["Unit"],"summary":"Delete Unit","description":"Delete Unit","operationId":"DeleteUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unit could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Unit"],"summary":"Get Unit","description":"Get Unit","operationId":"GetUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Unit with capability to extend additional related entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedUnit"}}}},"200":{"description":"Unit with capability to extend additional related entities.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedUnit"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Unit"],"summary":"Patch Unit","description":"Patch Unit","operationId":"PatchUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"revision_id","in":"query","description":"Unique identifier for a revision_id","required":false,"schema":{"type":"string","format":"uuid","x-go-name":"RevisionID"}},{"name":"dry_run","in":"query","description":"Flag parameter for enabling dry_run","required":false,"schema":{"type":"boolean"}},{"name":"upgrade","in":"query","description":"Flag parameter for enabling upgrade","required":false,"schema":{"type":"boolean"}},{"name":"restore","in":"query","description":"Restore revision source. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_source","in":"query","description":"Merge source unit. Currently it must be a unit ID or 'Self'.","required":false,"schema":{"type":"string"}},{"name":"merge_base","in":"query","description":"Merge base revision of the merge source, which provides the base configuration data of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_end","in":"query","description":"Merge end revision of the merge source, which provides the final configuration of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"where_mutation","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Mutations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Mutation: CreatedAt, FunctionName, InvocationID, LinkID, MergeBaseRevisionNum, MergeEndRevisionNum, MergeSourceID, MutationID, MutationNum, OrganizationID, RestoredRevisionNum, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt, UpgradedFromUpstreamRevisionNum.\n\nUsed to filter which mutations are affected during merge operations.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_mutation","in":"query","description":"UUID of a Filter entity to apply to the Mutation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Mutation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"tag","in":"query","description":"Tag ID to add to the head revision","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"query","description":"Must match ChangeSetID of affected Units if config Data is changed unless in dry run mode","required":false,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"ChangeSetID":{"type":"string","description":"Unique identifier for the ChangeSet to which the current Revision belongs. Optional. Units are not required to belong to ChangeSets.","format":"uuid","nullable":true},"Data":{"type":"string","description":"The full configuration data for this unit.","format":"byte","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DestroyGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block destroy operations","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"LastChangeDescription":{"type":"string","description":"LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"TargetID":{"type":"string","description":"TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.","format":"uuid","nullable":true},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain for this unit. Possible values include \"Kubernetes/YAML\", \"OpenTofu/HCL\", \"AppConfig/Properties\", \"ConfigHub/YAML\".","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Unit. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"200":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to patch unit(s) due to configuration data problem","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["Unit"],"summary":"Update Unit","description":"Update Unit","operationId":"UpdateUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"revision_id","in":"query","description":"Unique identifier for a revision_id","required":false,"schema":{"type":"string","format":"uuid","x-go-name":"RevisionID"}},{"name":"dry_run","in":"query","description":"Flag parameter for enabling dry_run","required":false,"schema":{"type":"boolean"}},{"name":"upgrade","in":"query","description":"Flag parameter for enabling upgrade","required":false,"schema":{"type":"boolean"}},{"name":"restore","in":"query","description":"Restore revision source. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_source","in":"query","description":"Merge source unit. Currently it must be a unit ID or 'Self'.","required":false,"schema":{"type":"string"}},{"name":"merge_base","in":"query","description":"Merge base revision of the merge source, which provides the base configuration data of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_end","in":"query","description":"Merge end revision of the merge source, which provides the final configuration of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"where_mutation","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Mutations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Mutation: CreatedAt, FunctionName, InvocationID, LinkID, MergeBaseRevisionNum, MergeEndRevisionNum, MergeSourceID, MutationID, MutationNum, OrganizationID, RestoredRevisionNum, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt, UpgradedFromUpstreamRevisionNum.\n\nUsed to filter which mutations are affected during merge operations.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_mutation","in":"query","description":"UUID of a Filter entity to apply to the Mutation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Mutation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"tag","in":"query","description":"Tag ID to add to the head revision","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"query","description":"Must match ChangeSetID of affected Units if config Data is changed unless in dry run mode","required":false,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"responses":{"default":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"200":{"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Unit"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"Unit data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to update unit(s) due to configuration data problem","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/apply":{"post":{"tags":["Unit"],"summary":"Apply a unit configuration","description":"Triggers an apply operation using the config data to a Bridge Worker","operationId":"ApplyUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"revision","in":"query","description":"Revision to apply (defaults to HeadRevisionNum). Can be a revision number, 'LiveRevisionNum', 'LastAppliedRevisionNum', 'Tag:uuid', 'ChangeSet:uuid', etc.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"200":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Bridge worker unavailable","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/approve":{"post":{"tags":["Unit"],"summary":"Approve a unit configuration","description":"Record that the user invoking this operation approves the configuration data","operationId":"ApproveUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"revision","in":"query","description":"Revision to approve (defaults to HeadRevisionNum). Can be a revision number, 'LiveRevisionNum', 'LastAppliedRevisionNum', 'Tag:uuid', 'ChangeSet:uuid', etc.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"string"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/data":{"get":{"tags":["Unit"],"summary":"Download config data","description":"Download the config data of a unit","operationId":"DownloadUnitData","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/octet-stream":{"schema":{"type":"string","format":"base64"}}}},"200":{"description":"OK","content":{"application/octet-stream":{"schema":{"type":"string","format":"base64"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/destroy":{"post":{"tags":["Unit"],"summary":"Destroy a unit configuration","description":"Triggers a destroy operation using the config data to a Bridge Worker","operationId":"DestroyUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"200":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Bridge worker unavailable","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/extended":{"get":{"tags":["Unit"],"summary":"Get Unit details with expanded relationships","description":"Get Unit details with expanded relationships","operationId":"GetUnitExtended","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitExtended"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitExtended"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/import":{"post":{"tags":["Unit"],"summary":"Import a configuration unit","description":"Triggers an import operation using the config data to a Bridge Worker","operationId":"ImportUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ImportRequest"}}}},"responses":{"default":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"200":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Bridge worker unavailable","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/live-state":{"get":{"tags":["Unit"],"summary":"Download live state","description":"Download the live state of a unit","operationId":"DownloadUnitLiveState","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/octet-stream":{"schema":{"type":"string","format":"base64"}}}},"200":{"description":"OK","content":{"application/octet-stream":{"schema":{"type":"string","format":"base64"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/mutation":{"get":{"tags":["Mutation"],"summary":"List ExtendedMutations","description":"List ExtendedMutations","operationId":"ListExtendedMutations","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Mutations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Mutation: CreatedAt, FunctionName, InvocationID, LinkID, MergeBaseRevisionNum, MergeEndRevisionNum, MergeSourceID, MutationID, MutationNum, OrganizationID, RestoredRevisionNum, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt, UpgradedFromUpstreamRevisionNum.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Mutation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Mutation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Mutation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Mutation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Mutation are InvocationID, LinkID, MergeSourceID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Mutation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, MutationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedMutation"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedMutation"}}}}},"400":{"description":"ExtendedMutation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ExtendedMutation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ExtendedMutation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/mutation/{mutation_id}":{"get":{"tags":["Mutation"],"summary":"Get ExtendedMutation","description":"Get ExtendedMutation","operationId":"GetExtendedMutation","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Mutation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Mutation are InvocationID, LinkID, MergeSourceID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Mutation.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, MutationID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"mutation_id","in":"path","description":"Unique identifier for a mutation_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedMutation"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedMutation"}}}},"400":{"description":"ExtendedMutation request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ExtendedMutation not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ExtendedMutation.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/refresh":{"post":{"tags":["Unit"],"summary":"Refresh a unit configuration","description":"Triggers a refresh operation using the config data to a Bridge Worker","operationId":"RefreshUnit","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"200":{"description":"QueuedOperation is a record of an operation to be done by a bridge worker.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/QueuedOperation"}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Bridge worker unavailable","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/revision":{"get":{"tags":["Revision"],"summary":"List ExtendedRevisions","description":"List ExtendedRevisions","operationId":"ListExtendedRevisions","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Revisions returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Revision: ApplyGates, ApprovedBy, ChangeSetID, CreatedAt, Description, LiveAt, OrganizationID, RevisionID, RevisionNum, Source, SpaceID, Tags, UnitID, UpdatedAt, UserAgent, UserID.\n\nTo list a tagged Revision use `Tags ? '\u003ctag-id\u003e'`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Revision list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Revision).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Revision include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Revision are ChangeSetID, OrganizationID, SpaceID, Tags, UnitID, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, RevisionID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedRevision"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedRevision"}}}}},"400":{"description":"ExtendedRevision request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ExtendedRevision not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ExtendedRevision.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/revision/{revision_id}":{"get":{"tags":["Revision"],"summary":"Get ExtendedRevision","description":"Get ExtendedRevision","operationId":"GetExtendedRevision","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Revision are ChangeSetID, OrganizationID, SpaceID, Tags, UnitID, UserID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Revision.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, RevisionID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"revision_id","in":"path","description":"Unique identifier for a revision_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedRevision"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedRevision"}}}},"400":{"description":"ExtendedRevision request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"ExtendedRevision not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing ExtendedRevision.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/revision/{revision_id}/data":{"get":{"tags":["Revision"],"summary":"Download the selected Revision's data","description":"Download the selected Revision's data","operationId":"DownloadRevisionData","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"revision_id","in":"path","description":"Unique identifier for a revision_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/octet-stream":{"schema":{"type":"string"}}}},"200":{"description":"OK","content":{"application/octet-stream":{"schema":{"type":"string"}}}},"400":{"description":"Revision request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Revision not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Revision.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/unit_action":{"get":{"tags":["UnitAction"],"summary":"List UnitActions","description":"List UnitActions","operationId":"ListUnitActions","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of QueuedOperations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on QueuedOperation: BridgeWorkerID, CreatedAt, OrganizationID, QueuedOperationID, RevisionNum, SpaceID, Status, TargetID, UnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the QueuedOperation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (QueuedOperation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for QueuedOperation include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitAction"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitAction"}}}}},"400":{"description":"UnitAction request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"UnitAction not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing UnitAction.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/unit_action/{unit_action_id}":{"get":{"tags":["UnitAction"],"summary":"Get UnitAction","description":"Get UnitAction","operationId":"GetUnitAction","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_action_id","in":"path","description":"Unique identifier for a unit_action_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitAction"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitAction"}}}},"400":{"description":"UnitAction request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"UnitAction not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing UnitAction.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/unit_event":{"get":{"tags":["UnitEvent"],"summary":"List UnitEvents","description":"List UnitEvents","operationId":"ListUnitEvents","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of UnitEvents returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on UnitEvent: Action, BridgeWorkerID, CreatedAt, OrganizationID, QueuedOperationID, Result, RevisionNum, SpaceID, StartedAt, Status, TerminatedAt, UnitEventID, UnitID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the UnitEvent list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (UnitEvent).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for UnitEvent include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitEvent"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitEvent"}}}}},"400":{"description":"UnitEvent request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"UnitEvent not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing UnitEvent.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/unit/{unit_id}/unit_event/{unit_event_id}":{"get":{"tags":["UnitEvent"],"summary":"Get UnitEvent","description":"Get UnitEvent","operationId":"GetUnitEvent","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_id","in":"path","description":"Unique identifier for a unit_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"unit_event_id","in":"path","description":"Unique identifier for a unit_event_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks\nthe lifecycle of applying, destroying, or refreshing a Unit's configuration in the target\nlive system. The event captures the current status of the operation, any configuration\ndrift detected, and timing information about when the action started and completed.\nActions are atomic from ConfigHub's perspective but may involve multiple steps\nin the connected Bridge. The status and drift detection help track the health\nand consistency of the provisioned configuration compared to what is defined in the Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitEvent"}}}},"200":{"description":"UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks\nthe lifecycle of applying, destroying, or refreshing a Unit's configuration in the target\nlive system. The event captures the current status of the operation, any configuration\ndrift detected, and timing information about when the action started and completed.\nActions are atomic from ConfigHub's perspective but may involve multiple steps\nin the connected Bridge. The status and drift detection help track the health\nand consistency of the provisioned configuration compared to what is defined in the Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitEvent"}}}},"400":{"description":"UnitEvent request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"UnitEvent not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing UnitEvent.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/view":{"get":{"tags":["View"],"summary":"List Views","description":"List Views","operationId":"ListViews","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Views returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the View list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (View).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for View include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedView"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedView"}}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["View"],"summary":"Create View","description":"Create View","operationId":"CreateView","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"responses":{"default":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"200":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/space/{space_id}/view/{view_id}":{"delete":{"tags":["View"],"summary":"Delete View","description":"Delete View","operationId":"DeleteView","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"view_id","in":"path","description":"Unique identifier for a view_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"200":{"description":"Response for successful delete operation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteResponse"}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"View could not be deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["View"],"summary":"Get View","description":"Get View","operationId":"GetView","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"view_id","in":"path","description":"Unique identifier for a view_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedView"}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExtendedView"}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["View"],"summary":"Patch View","description":"Patch View","operationId":"PatchView","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"view_id","in":"path","description":"Unique identifier for a view_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Columns":{"type":"array","items":{"type":"object","nullable":true},"description":"","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FilterID":{"type":"string","description":"","format":"uuid","nullable":true},"GroupBy":{"type":"string","description":"","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"OrderBy":{"type":"string","description":"","nullable":true},"OrderByDirection":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for View. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"200":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"put":{"tags":["View"],"summary":"Update View","description":"Update View","operationId":"UpdateView","parameters":[{"name":"space_id","in":"path","description":"Unique identifier for a space_id","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"view_id","in":"path","description":"Unique identifier for a view_id","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"responses":{"default":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"200":{"description":"Defines an entity view.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/View"}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"409":{"description":"View data conflict. Data has changed since last read.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/tag":{"delete":{"tags":["Tag"],"summary":"Bulk delete multiple tags","description":"Delete multiple tags selected by query parameters","operationId":"BulkDeleteTags","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Tags returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Tag: ChangeSetID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Tag list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Tag).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Tag include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Tag"],"summary":"List of Tags across spaces","description":"Retrieves a list of Tags across spaces in the Organization","operationId":"ListAllTags","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Tags returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Tag: ChangeSetID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Tag list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Tag).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Tag include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTag"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTag"}}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Tag"],"summary":"Bulk patch multiple tags","description":"Apply JSON merge patch to multiple tags selected by query parameters","operationId":"BulkPatchTags","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Tags returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Tag: ChangeSetID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Tag list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Tag).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Tag include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Tag. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Tag"],"summary":"Bulk create (clone) multiple tags","description":"Clone multiple tags selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateTags","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Tags returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Tag: ChangeSetID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Tag list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Tag).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Tag include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Tag.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Tag are ChangeSetID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Tag names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning tags\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Tag. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TagCreateOrUpdateResponse"}}}}},"400":{"description":"Tag request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Tag not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Tag.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/target":{"delete":{"tags":["Target"],"summary":"Bulk delete multiple targets","description":"Delete multiple targets selected by query parameters","operationId":"BulkDeleteTargets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Targets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Target list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Target).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Target include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Target"],"summary":"List of Targets across spaces","description":"Retrieves a list of Targets across spaces in the Organization","operationId":"ListAllTargets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Targets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Target list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Target).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Target include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTarget"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTarget"}}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Target"],"summary":"Bulk patch multiple targets","description":"Apply JSON merge patch to multiple targets selected by query parameters","operationId":"BulkPatchTargets","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Targets returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Target list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Target).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Target include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Target.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Parameters":{"type":"string","description":"","nullable":true},"ProviderType":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Target. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TargetCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TargetCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TargetCreateOrUpdateResponse"}}}}},"400":{"description":"Target request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Target not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Target.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/trigger":{"delete":{"tags":["Trigger"],"summary":"Bulk delete multiple triggers","description":"Delete multiple triggers selected by query parameters","operationId":"BulkDeleteTriggers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Trigger list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Trigger).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Trigger include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Trigger"],"summary":"List of Triggers across spaces","description":"Retrieves a list of Triggers across spaces in the Organization","operationId":"ListAllTriggers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Trigger list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Trigger).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Trigger include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTrigger"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedTrigger"}}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Trigger"],"summary":"Bulk patch multiple triggers","description":"Apply JSON merge patch to multiple triggers selected by query parameters","operationId":"BulkPatchTriggers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Trigger list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Trigger).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Trigger include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Disabled":{"type":"boolean","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Enforced":{"type":"boolean","description":"","nullable":true},"Event":{"type":"string","description":"","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"InvocationID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Trigger. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Trigger"],"summary":"Bulk create (clone) multiple triggers","description":"Clone multiple triggers selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateTriggers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Trigger list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Trigger).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Trigger include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Trigger.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Trigger names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning triggers\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Arguments":{"type":"array","items":{"type":"object","nullable":true},"description":"Function arguments","nullable":true},"BridgeWorkerID":{"type":"string","description":"","format":"uuid","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"Disabled":{"type":"boolean","description":"","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Enforced":{"type":"boolean","description":"","nullable":true},"Event":{"type":"string","description":"","nullable":true},"FunctionName":{"type":"string","description":"Function name","nullable":true},"InvocationID":{"type":"string","description":"","format":"uuid","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"ToolchainType":{"type":"string","description":"","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Trigger. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TriggerCreateOrUpdateResponse"}}}}},"400":{"description":"Trigger request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Trigger not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Trigger.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit":{"delete":{"tags":["Unit"],"summary":"Bulk delete multiple units","description":"Delete multiple units selected by query parameters","operationId":"BulkDeleteUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entities","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["Unit"],"summary":"List of Units across spaces","description":"Retrieves a list of Units across spaces in the Organization","operationId":"ListAllUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"resource_type","in":"query","description":"Resource type: Resource type to match for the desired ToolchainType, for example apps/v1/Deployment","required":false,"schema":{"type":"string"}},{"name":"where_data","in":"query","description":"Where data: The specified string is an expression for the purpose of evaluating whether the configuration data matches the filter. It supports conjunctions using `AND` of relational expressions of the form *path* *operator* *literal*. The path specifications are dot-separated, for both map fields and array indices, as in `spec.template.spec.containers.0.image = 'ghcr.io/headlamp-k8s/headlamp:latest' AND spec.replicas \u003e 1`. Path expressions support `*` for wildcard array or map segments and `?key=value` syntax for associative matches of array elements containing objects with a `key` attribute. Strings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `!~`, `~*`, `!~*`, `IN`, `NOT IN`. String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards, `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE. String regex operators: `~` for regex matching, `~*` for case-insensitive regex, `!~` and `!~*` for regex not matching (case-sensitive and insensitive). Integers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`. Boolean values support equality and inequality only. The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses, such as `spec.template.spec.containers.0.image#reference IN (':latest', ':arm64-latest')`. The syntax `.|` requires the preceding path to exist; otherwise the relation `!=` will always return true regardless what it is compared with. String literals are quoted with single quotes, such as `'string'`. Integer and boolean literals are also supported for attributes of those types. The whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedUnit"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["Unit"],"summary":"Bulk patch multiple units","description":"Apply JSON merge patch to multiple units selected by query parameters","operationId":"BulkPatchUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"dry_run","in":"query","description":"Flag parameter for enabling dry_run","required":false,"schema":{"type":"boolean"}},{"name":"upgrade","in":"query","description":"Flag parameter for enabling upgrade","required":false,"schema":{"type":"boolean"}},{"name":"restore","in":"query","description":"Restore revision source. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_source","in":"query","description":"Merge source unit. Currently it must be a unit ID or 'Self'.","required":false,"schema":{"type":"string"}},{"name":"merge_base","in":"query","description":"Merge base revision of the merge source, which provides the base configuration data of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"merge_end","in":"query","description":"Merge end revision of the merge source, which provides the final configuration of the changes to merge. Supports: Named revisions ('LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', 'HeadRevisionNum'), direct revision number (e.g., '42'), or entity references ('Tag:uuid', 'ChangeSet:uuid', 'Revision:uuid'). Can be prefixed with 'Before:' to select the revision immediately before the specified one (e.g., 'Before:LiveRevisionNum', 'Before:42'). When using Tag or ChangeSet references, the latest revision associated with that entity is selected.","required":false,"schema":{"type":"string"}},{"name":"where_mutation","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Mutations returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Mutation: CreatedAt, FunctionName, InvocationID, LinkID, MergeBaseRevisionNum, MergeEndRevisionNum, MergeSourceID, MutationID, MutationNum, OrganizationID, RestoredRevisionNum, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt, UpgradedFromUpstreamRevisionNum.\n\nUsed to filter which mutations are affected during merge operations.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_mutation","in":"query","description":"UUID of a Filter entity to apply to the Mutation list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Mutation).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"tag","in":"query","description":"Tag ID to add to the head revision","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"change_set_id","in":"query","description":"Must match ChangeSetID of affected Units if config Data is changed unless in dry run mode","required":false,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"ChangeSetID":{"type":"string","description":"Unique identifier for the ChangeSet to which the current Revision belongs. Optional. Units are not required to belong to ChangeSets.","format":"uuid","nullable":true},"Data":{"type":"string","description":"The full configuration data for this unit.","format":"byte","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DestroyGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block destroy operations","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"LastChangeDescription":{"type":"string","description":"LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"TargetID":{"type":"string","description":"TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.","format":"uuid","nullable":true},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain for this unit. Possible values include \"Kubernetes/YAML\", \"OpenTofu/HCL\", \"AppConfig/Properties\", \"ConfigHub/YAML\".","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Unit. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to patch unit(s) due to configuration data problem","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["Unit"],"summary":"Bulk create (clone) multiple units","description":"Clone multiple units selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned Unit names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning units\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"ChangeSetID":{"type":"string","description":"Unique identifier for the ChangeSet to which the current Revision belongs. Optional. Units are not required to belong to ChangeSets.","format":"uuid","nullable":true},"Data":{"type":"string","description":"The full configuration data for this unit.","format":"byte","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DestroyGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block destroy operations","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"LastChangeDescription":{"type":"string","description":"LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"TargetID":{"type":"string","description":"TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.","format":"uuid","nullable":true},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain for this unit. Possible values include \"Kubernetes/YAML\", \"OpenTofu/HCL\", \"AppConfig/Properties\", \"ConfigHub/YAML\".","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for Unit. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitCreateOrUpdateResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to create unit(s) due to configuration data problem","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit/apply":{"post":{"tags":["Unit"],"summary":"Bulk apply units","description":"Executes apply operations for multiple units based on filter criteria across spaces","operationId":"BulkApplyUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":true,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"dry_run","in":"query","description":"Dry run mode - validates which units would be applied without executing","required":false,"schema":{"type":"boolean"}},{"name":"revision","in":"query","description":"Revision to apply (defaults to HeadRevisionNum). Can be a revision number, 'LiveRevisionNum', 'LastAppliedRevisionNum', 'Tag:uuid', 'ChangeSet:uuid', etc.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to apply unit(s)","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit/approve":{"post":{"tags":["Unit"],"summary":"Bulk approve multiple units","description":"Record that the user invoking this operation approves multiple unit configurations using where and contains filters","operationId":"BulkApproveUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"revision","in":"query","description":"Revision to approve (defaults to HeadRevisionNum). Can be a revision number, 'LiveRevisionNum', 'LastAppliedRevisionNum', 'Tag:uuid', 'ChangeSet:uuid', etc.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ApproveResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ApproveResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ApproveResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit/destroy":{"post":{"tags":["Unit"],"summary":"Bulk destroy units","description":"Executes destroy operations for multiple units based on filter criteria across spaces","operationId":"BulkDestroyUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":true,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"dry_run","in":"query","description":"Dry run mode - validates which units would be destroyed without executing","required":false,"schema":{"type":"boolean"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to destroy unit(s)","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit/refresh":{"post":{"tags":["Unit"],"summary":"Bulk refresh units","description":"Executes refresh operations for multiple units based on filter criteria across spaces","operationId":"BulkRefreshUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":true,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"dry_run","in":"query","description":"Dry run mode - validates which units would be refreshed without executing","required":false,"schema":{"type":"boolean"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitActionResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to refresh unit(s)","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/unit/tag":{"post":{"tags":["Unit"],"summary":"Bulk tag multiple units","description":"Attach tags to specified unit revisions","operationId":"BulkTagUnits","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Units returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Unit: ApplyGates, ApprovedBy, BridgeWorkerID, ChangeSetID, CreatedAt, DeleteGates, DestroyGates, DisplayName, FromLinkID, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID, Values.\n\nFinding all units created by cloning can be done using the expression `UpstreamRevisionNum \u003e 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum \u003e LiveRevisionNum`.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the Unit list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Unit).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for Unit include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for Unit.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for Unit are ApprovedBy, BridgeWorkerID, ChangeSetID, FromLinkID, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UnitTagRequest"}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitTagResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitTagResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/UnitTagResponse"}}}}},"400":{"description":"Unit request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"Unit not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing Unit.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/user":{"get":{"tags":["User"],"summary":"List Users","description":"List Users","operationId":"ListUsers","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Users returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on User: CreatedAt, DisplayName, ExternalID, Slug, UpdatedAt, UserID, Username.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the User list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (User).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for User include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/User"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/User"}}}}},"400":{"description":"User request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"User not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing User.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/user/{user_id}":{"get":{"tags":["User"],"summary":"Get User","description":"Get User","operationId":"GetUser","parameters":[{"name":"user_id","in":"path","description":"Unique identifier for a user_id","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"a User in Confighub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"200":{"description":"a User in Confighub.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"400":{"description":"User request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"User not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing User.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}},"/view":{"delete":{"tags":["View"],"summary":"Bulk delete multiple views","description":"Delete multiple views selected by query parameters","operationId":"BulkDeleteViews","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Views returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the View list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (View).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for View include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DeleteResponse"}}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"422":{"description":"Unable to delete entity","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"get":{"tags":["View"],"summary":"List of Views across spaces","description":"Retrieves a list of Views across spaces in the Organization","operationId":"ListAllViews","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Views returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the View list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (View).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for View include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"select","in":"query","description":"Select clause for specifying which fields to include in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\nIf not specified, all fields are returned.\nEntity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.\nFields used in where and contains filters are also automatically included.\nExample: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedView"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtendedView"}}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"patch":{"tags":["View"],"summary":"Bulk patch multiple views","description":"Apply JSON merge patch to multiple views selected by query parameters","operationId":"BulkPatchViews","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Views returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the View list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (View).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for View include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Columns":{"type":"array","items":{"type":"object","nullable":true},"description":"","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FilterID":{"type":"string","description":"","format":"uuid","nullable":true},"GroupBy":{"type":"string","description":"","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"OrderBy":{"type":"string","description":"","nullable":true},"OrderByDirection":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for View. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status: Mixed success and failure results","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}},"post":{"tags":["View"],"summary":"Bulk create (clone) multiple views","description":"Clone multiple views selected by query parameters with optional name prefixes and destination spaces","operationId":"BulkCreateViews","parameters":[{"name":"where","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Views returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter","in":"query","description":"UUID of a Filter entity to apply to the View list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (View).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"contains","in":"query","description":"Free text search that approximately matches the specified string against string fields and map keys/values.\n\nThe search is case-insensitive and uses pattern matching to find entities containing the text.\n\nSearchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.\n\nFor map fields (like Labels and Annotations), the search matches both map keys and values.\n\nThe search uses OR logic across all searchable fields, so matching any field will return the entity.\n\nIf both 'where' and 'contains' parameters are specified, they are combined with AND logic.\n\nSearchable fields for View include string and map-type attributes from the queryable attributes list.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"include","in":"query","description":"Include clause for expanding related entities in the response for View.\nThe attribute names are case-sensitive, PascalCase, and\nexpected in a comma-separated list format as in the JSON encoding.\n\nSupported attributes for View are FilterID, OrganizationID, SpaceID.\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"name_prefixes","in":"query","description":"Comma-separated list of prefixes to apply to cloned View names","required":false,"schema":{"type":"string"}},{"name":"where_space","in":"query","description":"The specified string is an expression for the purpose of filtering\nthe list of Spaces returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Space: CreatedAt, DeleteGates, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.\n\nWhere expression to select destination spaces for cloning views\n\nThe whole string must be query-encoded.","required":false,"schema":{"type":"string"}},{"name":"filter_space","in":"query","description":"UUID of a Filter entity to apply to the Space list.\n\nThe Filter must be in the same Organization as the user credentials.\n\nThe Filter's From field must match the entity type being filtered (Space).\n\nFor Space-resident entities, if the Filter has a FromSpaceID, it must match the operation's SpaceID.\n\nThe Filter's Where clause will be combined with any explicit 'where' parameter using AND logic.\n\nIf both 'filter' and 'where' parameters are specified, they are combined with AND logic.","required":false,"schema":{"type":"string"}},{"name":"allow_exists","in":"query","description":"Allowed values are true and false. Default is false. When true, reports success when an entity already exists and returns the existing entity","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/merge-patch+json":{"schema":{"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","nullable":true},"Columns":{"type":"array","items":{"type":"object","nullable":true},"description":"","nullable":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean","nullable":true},"description":"An optional set of gates that, if any is present, will block deletion","nullable":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","nullable":true},"FilterID":{"type":"string","description":"","format":"uuid","nullable":true},"GroupBy":{"type":"string","description":"","nullable":true},"Labels":{"type":"object","additionalProperties":{"type":"string","nullable":true},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","nullable":true},"OrderBy":{"type":"string","description":"","nullable":true},"OrderByDirection":{"type":"string","description":"","nullable":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","nullable":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","nullable":true}},"description":"JSON Merge Patch schema for View. All fields are optional and nullable. Readonly fields are ignored."}}}},"responses":{"default":{"description":"","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"207":{"description":"Multi-Status (partial success)","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ViewCreateOrUpdateResponse"}}}}},"400":{"description":"View request is invalid (Bad Request).","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"401":{"description":"Unauthorized access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"403":{"description":"Forbidden access.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"404":{"description":"View not found.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}},"500":{"description":"Something went wrong while processing View.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/StandardErrorResponse"}}}}}}}},"components":{"schemas":{"ActionResult":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"Data":{"type":"string","description":"Configuration data of the Unit","format":"base64","x-go-type-skip-optional-pointer":true},"LiveState":{"type":"string","description":"Live state corresponding to the Unit","format":"base64","x-go-type-skip-optional-pointer":true},"Message":{"type":"string","x-go-type-skip-optional-pointer":true},"Outputs":{"type":"string","description":"Outputs resulting from applying the configuration data of the Unit","format":"base64","x-go-type-skip-optional-pointer":true},"QueuedOperationID":{"type":"string","description":"UUID of the operation corresponding to the action request","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Result":{"$ref":"#/components/schemas/ActionResultType"},"RevisionNum":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"UUID of the Space of the Unit on which the action is performed","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"StartedAt":{"type":"string","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"Status":{"$ref":"#/components/schemas/ActionStatusType"},"TerminatedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"UUID of the Unit on which the action is performed","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true}}},"ActionResultType":{"enum":["ApplyFailed","ApplyWaitFailed","ApplyCompleted","DestroyCompleted","DestroyWaitFailed","DestroyFailed","ImportCompleted","ImportFailed","RefreshAndDrifted","RefreshAndNoDrift","RefreshFailed","None"],"type":"string"},"ActionStatusType":{"enum":["None","Pending","Submitted","Progressing","Completed","Failed","Canceled"],"type":"string"},"ActionType":{"enum":["Apply","Destroy","Finalize","Heartbeat","Import","N/A","Refresh"],"type":"string"},"ApproveResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Message":{"type":"string","x-go-type-skip-optional-pointer":true}}},"BridgeWorker":{"required":["Slug"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"BridgeWorkerID":{"type":"string","description":"Unique identifier for a Bridge Worker.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Condition":{"type":"string","description":"Condition represents the worker's readiness state (Ready, NotReady, Unresponsive, Disconnected).","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"IPAddress":{"type":"string","description":"IPAddress is the IP address from which the worker last connected.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"LastMessage":{"type":"string","description":"LastMessage contains the last message from the worker (heartbeat message or other status).","readOnly":true,"x-go-type-skip-optional-pointer":true},"LastSeenAt":{"type":"string","description":"LastSeenAt is the time the worker was last seen (heartbeat, connection, or any event).","format":"date-time","readOnly":true,"example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ProvidedInfo":{"$ref":"#/components/schemas/WorkerInfo"},"Secret":{"type":"string","description":"Secret is a unique secret token for the bridge worker.\nIt's auto-generated when the BridgeWorker entity is created and cannot be modified.\nThis field is output-only and used for authentication.\nThis secret is required when starting the bridge worker program.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"UserID":{"$ref":"#/components/schemas/UUID"},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"BridgeWorker represents a bridge worker in ConfigHub.\nA bridge worker is a worker program that connects ConfigHub to external systems and targets.\nIt acts as a bridge between ConfigHub and the infrastructure where configurations need\nto be applied. Bridge workers are responsible for executing configuration changes on\nremote targets and reporting status back to ConfigHub.\nWhen starting a bridge worker program, both the BridgeWorkerID and Secret are\nrequired for authentication with the ConfigHub server. These credentials allow the\nbridge worker to establish a secure connection and receive configuration actions."},"BridgeWorkerCreateOrUpdateResponse":{"type":"object","properties":{"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"Error":{"$ref":"#/components/schemas/ResponseError"}}},"BridgeWorkerInfo":{"type":"object","properties":{"SupportedConfigTypes":{"type":"array","items":{"$ref":"#/components/schemas/ConfigType"},"description":"Configuration types supported by the BridgeWorker","x-go-type-skip-optional-pointer":true}}},"BridgeWorkerStatus":{"type":"object","properties":{"BridgeWorkerID":{"type":"string","description":"Unique identifier for the Bridge Worker.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"BridgeWorkerSlug":{"type":"string","description":"Slug for the Bridge Worker.","x-go-type-skip-optional-pointer":true},"BridgeWorkerStatusID":{"type":"string","description":"BridgeWorkerStatusID is the unique identifier for the bridge worker status entry.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"IPAddress":{"type":"string","description":"IPAddress is the IP address from which the bridge worker is connecting.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"OrganizationID is the unique identifier of the organization the bridge worker belongs to.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"SeenAt":{"type":"string","description":"The timestamp when the bridge worker last responded in \"2023-01-01T12:00:00Z\" format.","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"SpaceID is the unique identifier of the space the bridge worker belongs to.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Status":{"type":"string","description":"Status indicates the current status of the bridge worker. Possible values include Connected, Disconnected, ActionSent, ActionResultReceived.","x-go-type-skip-optional-pointer":true}},"description":"BridgeWorkerStatus represents the status information of a bridge worker within the system."},"ChangeSet":{"required":["Slug"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"ChangeSetID":{"type":"string","description":"ChangeSetID uniquely identifies a changeset within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"Description":{"type":"string","description":"Description is a human-readable description of the change.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EndTagID":{"type":"string","description":"EndTagID is the identifier of the set of revisions that end the ChangeSet.","format":"uuid","readOnly":true,"example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"StartTagID":{"type":"string","description":"StartTagID is the identifier of the set of revisions that begin the ChangeSet.","format":"uuid","readOnly":true,"example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"State":{"type":"string","description":"State represents the current state of the ChangeSet.","readOnly":true,"x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Defines an entity changeset."},"ChangeSetCreateOrUpdateResponse":{"type":"object","properties":{"ChangeSet":{"$ref":"#/components/schemas/ChangeSet"},"Error":{"$ref":"#/components/schemas/ResponseError"}}},"Column":{"required":["Name"],"type":"object","properties":{"Name":{"type":"string","description":"Name of the column in PascalCase without spaces or dashes, if built-in, entity attribute (e.g., Labels.Environment), or extended attribute (e.g., UpstreamUnit.HeadRevisionNum)","x-go-type-skip-optional-pointer":true}}},"ConfigType":{"type":"object","properties":{"AvailableTargets":{"type":"array","items":{"$ref":"#/components/schemas/TargetType2"},"description":"Targets known by the BridgeWorker","x-go-type-skip-optional-pointer":true},"ProviderType":{"type":"string","description":"Provider subtype of the configuration toolchain supported by the BridgegWorker","x-go-type-skip-optional-pointer":true},"ToolchainType":{"type":"string","description":"Configuration toolchain and format supported by the BridgeWorker","x-go-type-skip-optional-pointer":true}}},"DeleteResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Message":{"type":"string","description":"Response message.","x-go-type-skip-optional-pointer":true}},"description":"Response for successful delete operation"},"ErrorItem":{"type":"object","properties":{"Description":{"type":"string","description":"A clear explanation of what went wrong","x-go-type-skip-optional-pointer":true},"Item":{"type":"string","description":"The name of the field, resource, or entity that the error relates to","x-go-type-skip-optional-pointer":true}}},"ErrorMetadata":{"type":"object","properties":{"EntityID":{"type":"string","description":"Optional ID of the entity this error relates to","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"Optional type of the entity this error relates to","x-go-type-skip-optional-pointer":true},"Items":{"type":"array","items":{"$ref":"#/components/schemas/ErrorItem"},"description":"Collection of error details","x-go-type-skip-optional-pointer":true}}},"EventMessage":{"type":"object","properties":{"Data":{"type":"string","format":"base64"},"Event":{"type":"string"}}},"ExtendedBridgeWorker":{"type":"object","properties":{"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"TargetCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true}}},"ExtendedChangeSet":{"type":"object","properties":{"ChangeSet":{"$ref":"#/components/schemas/ChangeSet"},"EndTag":{"$ref":"#/components/schemas/Tag"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"StartTag":{"$ref":"#/components/schemas/Tag"}}},"ExtendedFilter":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Filter":{"$ref":"#/components/schemas/Filter"},"FromSpace":{"$ref":"#/components/schemas/Space"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"}}},"ExtendedInvocation":{"type":"object","properties":{"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Invocation":{"$ref":"#/components/schemas/Invocation"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"}}},"ExtendedLink":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"FromUnit":{"$ref":"#/components/schemas/Unit"},"Link":{"$ref":"#/components/schemas/Link"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"ToSpace":{"$ref":"#/components/schemas/Space"},"ToUnit":{"$ref":"#/components/schemas/Unit"}}},"ExtendedMutation":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Invocation":{"$ref":"#/components/schemas/Invocation"},"Link":{"$ref":"#/components/schemas/Link"},"MergeSource":{"$ref":"#/components/schemas/Unit"},"Mutation":{"$ref":"#/components/schemas/Mutation"},"Organization":{"$ref":"#/components/schemas/Organization"},"Revision":{"$ref":"#/components/schemas/Revision"},"Space":{"$ref":"#/components/schemas/Space"},"Trigger":{"$ref":"#/components/schemas/Trigger"},"Unit":{"$ref":"#/components/schemas/Unit"}}},"ExtendedRevision":{"type":"object","properties":{"ChangeSet":{"$ref":"#/components/schemas/ChangeSet"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Organization":{"$ref":"#/components/schemas/Organization"},"Revision":{"$ref":"#/components/schemas/Revision"},"Space":{"$ref":"#/components/schemas/Space"},"Tags":{"type":"array","items":{"$ref":"#/components/schemas/Tag"},"x-go-type-skip-optional-pointer":true},"Unit":{"$ref":"#/components/schemas/Unit"},"User":{"$ref":"#/components/schemas/User"}}},"ExtendedSpace":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"GatedUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"IncompleteApplyUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"TargetCountByToolchainType":{"type":"object","additionalProperties":{"type":"integer"},"nullable":true,"x-go-type-skip-optional-pointer":true},"TotalBridgeWorkerCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalChangeSetCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalFilterCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalInvocationCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalLinkCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalTagCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TotalViewCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"TriggerCountByEventType":{"type":"object","additionalProperties":{"type":"integer"},"nullable":true,"x-go-type-skip-optional-pointer":true},"UnappliedUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"UnapprovedUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"UnlinkedUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"UpgradableUnitCount":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true}}},"ExtendedTag":{"type":"object","properties":{"ChangeSet":{"$ref":"#/components/schemas/ChangeSet"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"Tag":{"$ref":"#/components/schemas/Tag"}}},"ExtendedTarget":{"type":"object","properties":{"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"Target":{"$ref":"#/components/schemas/Target"}}},"ExtendedTrigger":{"type":"object","properties":{"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"Error":{"$ref":"#/components/schemas/ResponseError"},"Invocation":{"$ref":"#/components/schemas/Invocation"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"Trigger":{"$ref":"#/components/schemas/Trigger"}}},"ExtendedUnit":{"type":"object","properties":{"ApprovedBy":{"type":"array","items":{"$ref":"#/components/schemas/User"},"description":"the users that have approved the latest revision of the config data.","x-go-type-skip-optional-pointer":true},"BridgeWorker":{"$ref":"#/components/schemas/BridgeWorker"},"ChangeSet":{"$ref":"#/components/schemas/ChangeSet"},"Error":{"$ref":"#/components/schemas/ResponseError"},"FromLink":{"type":"array","items":{"$ref":"#/components/schemas/Link"},"x-go-type-skip-optional-pointer":true},"HeadMutation":{"$ref":"#/components/schemas/Mutation"},"HeadRevision":{"$ref":"#/components/schemas/Revision"},"LastAppliedRevision":{"$ref":"#/components/schemas/Revision"},"LatestUnitEvent":{"$ref":"#/components/schemas/UnitEvent"},"LiveRevision":{"$ref":"#/components/schemas/Revision"},"Organization":{"$ref":"#/components/schemas/Organization"},"PreviousLiveRevision":{"$ref":"#/components/schemas/Revision"},"Space":{"$ref":"#/components/schemas/Space"},"Target":{"$ref":"#/components/schemas/Target"},"Unit":{"$ref":"#/components/schemas/Unit"},"UnitStatus":{"$ref":"#/components/schemas/UnitStatus"},"UpstreamSpace":{"$ref":"#/components/schemas/Space"},"UpstreamUnit":{"$ref":"#/components/schemas/Unit"}},"description":"Unit with capability to extend additional related entities."},"ExtendedView":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Filter":{"$ref":"#/components/schemas/Filter"},"Organization":{"$ref":"#/components/schemas/Organization"},"Space":{"$ref":"#/components/schemas/Space"},"View":{"$ref":"#/components/schemas/View"}}},"Filter":{"required":["Slug","From"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FilterID":{"type":"string","description":"FilterID uniquely identifies a filter within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"From":{"type":"string","description":"From specifies the type of entity (Unit, Space, etc.) to filter, in PascalCase.","x-go-type-skip-optional-pointer":true},"FromSpaceID":{"$ref":"#/components/schemas/UUID"},"Hash":{"type":"string","description":"SHA256 hash of the filter parameters encoded as hexadecimal. (readonly)","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ResourceType":{"type":"string","description":"Resource type to match for the desired ToolchainType, for example apps/v1/Deployment. Valid only for Units. (optional)","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true},"Where":{"type":"string","description":"Where specifices the where filter expression in the syntax used in list and search API query parameters. (optional)","x-go-type-skip-optional-pointer":true},"WhereData":{"type":"string","description":"WhereData specifies a filter expression for configuration data. Valid only for Units. (optional)","x-go-type-skip-optional-pointer":true}},"description":"Defines an entity filter."},"FilterCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Filter":{"$ref":"#/components/schemas/Filter"}}},"FunctionArgument":{"type":"object","properties":{"Evaluator":{"type":"string"},"ParameterName":{"type":"string"},"Value":{"anyOf":[{"type":"string"},{"type":"integer","format":"int64"},{"type":"boolean"}]}}},"FunctionInvocation":{"type":"object","properties":{"Arguments":{"type":"array","items":{"$ref":"#/components/schemas/FunctionArgument"},"description":"Function arguments","nullable":true,"x-go-type-skip-optional-pointer":true},"FunctionName":{"type":"string","description":"Function name","x-go-type-skip-optional-pointer":true}}},"FunctionInvocationList":{"type":"array","items":{"$ref":"#/components/schemas/FunctionInvocation"},"nullable":true},"FunctionInvocationsRequest":{"type":"object","properties":{"BridgeWorkerID":{"$ref":"#/components/schemas/UUID"},"ChangeDescription":{"type":"string","description":"ChangeDescription is a description of the change being made, if any.","x-go-type-skip-optional-pointer":true},"FunctionInvocations":{"$ref":"#/components/schemas/FunctionInvocationList"},"Invocations":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"Invocations is a list of Invocation IDs to execute. The invocations must be within the same Organization. Invocations will be executed after the FunctionInvocations list. Functions are grouped by executor (built-in vs bridge worker) and executed in phases: general mutating functions first, then final mutating functions (like ensure-context), then validating functions. Functions that don't match the unit's toolchain type are ignored.","x-go-type-skip-optional-pointer":true},"NumFilters":{"type":"integer","description":"NumFilters is the number of validating functions from the FunctionInvocations to treat as filters for the remaining functions in the list. In the case that the validation function does not pass, stop and don't execute the remaining functions, but don't report an error.","x-go-type-skip-optional-pointer":true},"StopOnError":{"type":"boolean","description":"StopOnError indicates whether to stop executing functions from the FunctionInvocations list on the first error, or to execute all of the functions and return all of the errors. Note that this applies to each Unit or Revision individually rather than all of the entities on which the functions are being invoked.","x-go-type-skip-optional-pointer":true},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain for these function invocations. This determines which configuration formats the functions can process.","x-go-type-skip-optional-pointer":true},"Triggers":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"Triggers is a list of Trigger IDs to execute. The triggers must be within the same Organization. Triggers will be executed after the FunctionInvocations list. Functions are grouped by executor (built-in vs bridge worker) and executed in phases: general mutating functions first, then final mutating functions (like ensure-context), then validating functions. Functions that don't match the unit's toolchain type are ignored.","x-go-type-skip-optional-pointer":true}},"description":"FunctionInvocationsRequest represents a request to invoke a list of functions on the configuration data of the matching Units or Revision."},"FunctionInvocationsResponse":{"type":"object","properties":{"ConfigData":{"type":"string","description":"The resulting configuration data, potentially mutated","format":"base64","x-go-type-skip-optional-pointer":true},"Error":{"$ref":"#/components/schemas/ResponseError"},"Mutations":{"$ref":"#/components/schemas/ResourceMutationList"},"Mutators":{"type":"array","items":{"type":"integer"},"description":"List of function invocation indices that resulted in mutations","nullable":true,"x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"ID of the Unit's Organization","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Outputs":{"type":"object","additionalProperties":{"type":"string","format":"base64"},"description":"Map of output types to their corresponding output data as embedded JSON","nullable":true,"x-go-type-skip-optional-pointer":true},"RevisionID":{"type":"string","description":"ID of the Revision the configuration data is associated with","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"ID of the Unit's Space","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Success":{"type":"boolean","description":"True if all functions executed successfully","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"ID of the Unit the configuration data is associated with","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true}}},"FunctionOutput":{"type":"object","properties":{"Description":{"type":"string","description":"Description of the result","x-go-type-skip-optional-pointer":true},"OutputType":{"type":"string","description":"Data type of the JSON embedded in the output","x-go-type-skip-optional-pointer":true},"ResultName":{"type":"string","description":"Name of the result in kabob-case","x-go-type-skip-optional-pointer":true}}},"FunctionParameter":{"type":"object","properties":{"DataType":{"type":"string","description":"Data type of the parameter","x-go-type-skip-optional-pointer":true},"Description":{"type":"string","description":"Description of the parameter","x-go-type-skip-optional-pointer":true},"EnumValues":{"type":"array","items":{"type":"string"},"description":"List of valid enum values; applies to enum parameters","x-go-type-skip-optional-pointer":true},"Example":{"type":"string","description":"Example value","x-go-type-skip-optional-pointer":true},"Max":{"type":"integer","description":"Maximum allowed value; applies to int parameters","nullable":true,"x-go-type-skip-optional-pointer":true},"Min":{"type":"integer","description":"Minimum allowed value; applies to int parameters","nullable":true,"x-go-type-skip-optional-pointer":true},"ParameterName":{"type":"string","description":"Name of the parameter in kabob-case","x-go-type-skip-optional-pointer":true},"Regexp":{"type":"string","description":"Regular expression matching valid values; applies to string parameters","x-go-type-skip-optional-pointer":true},"Required":{"type":"boolean","description":"Whether the parameter is required","x-go-type-skip-optional-pointer":true}}},"FunctionSignature":{"type":"object","properties":{"AffectedResourceTypes":{"type":"array","items":{"type":"string"},"description":"Resource types the function applies to; * if all","x-go-type-skip-optional-pointer":true},"AttributeName":{"type":"string","description":"Attribute corresponding to registered paths, if a path visitor; optional","x-go-type-skip-optional-pointer":true},"Description":{"type":"string","description":"Description of the function","x-go-type-skip-optional-pointer":true},"FunctionName":{"type":"string","description":"Name of the function in kabob-case","x-go-type-skip-optional-pointer":true},"FunctionType":{"type":"string","description":"Implementation pattern of the function: PathVisitor or Custom","x-go-type-skip-optional-pointer":true},"Hermetic":{"type":"boolean","description":"Does not call other systems","x-go-type-skip-optional-pointer":true},"Idempotent":{"type":"boolean","description":"Will return the same result if invoked again","x-go-type-skip-optional-pointer":true},"Mutating":{"type":"boolean","description":"May change the configuration data","x-go-type-skip-optional-pointer":true},"OutputInfo":{"$ref":"#/components/schemas/FunctionOutput"},"Parameters":{"type":"array","items":{"$ref":"#/components/schemas/FunctionParameter"},"description":"Function parameters, in order","nullable":true,"x-go-type-skip-optional-pointer":true},"RequiredParameters":{"type":"integer","description":"Number of required parameters","x-go-type-skip-optional-pointer":true},"Validating":{"type":"boolean","description":"Returns ValidationResult","x-go-type-skip-optional-pointer":true},"VarArgs":{"type":"boolean","description":"Last parameter may be repeated","x-go-type-skip-optional-pointer":true}}},"FunctionWorkerInfo":{"type":"object","properties":{"SupportedFunctions":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/FunctionSignature"}},"nullable":true,"x-go-type-skip-optional-pointer":true}}},"ImportFilter":{"type":"object","properties":{"Operator":{"type":"string","x-go-type-skip-optional-pointer":true},"Type":{"type":"string","x-go-type-skip-optional-pointer":true},"Values":{"type":"array","items":{"type":"string"},"x-go-type-skip-optional-pointer":true}}},"ImportOptions":{"type":"object","additionalProperties":{}},"ImportRequest":{"type":"object","properties":{"Filters":{"type":"array","items":{"$ref":"#/components/schemas/ImportFilter"},"x-go-type-skip-optional-pointer":true},"Options":{"$ref":"#/components/schemas/ImportOptions"},"ResourceInfoList":{"$ref":"#/components/schemas/ResourceInfoList"},"Where":{"type":"string","x-go-type-skip-optional-pointer":true}}},"Invocation":{"required":["Slug","ToolchainType"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"Arguments":{"type":"array","items":{"$ref":"#/components/schemas/FunctionArgument"},"description":"Function arguments","nullable":true,"x-go-type-skip-optional-pointer":true},"BridgeWorkerID":{"$ref":"#/components/schemas/UUID"},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FunctionName":{"type":"string","description":"Function name","x-go-type-skip-optional-pointer":true},"Hash":{"type":"string","description":"SHA256 hash of the function name and arguments encoded as hexadecimal.","readOnly":true,"x-go-type-skip-optional-pointer":true},"InvocationID":{"type":"string","description":"InvocationID uniquely identifies a invocation within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ToolchainType":{"required":["true"],"type":"string","description":"ToolchainType specifies the type of toolchain this invocation works with.\n\t\tThis determines which configuration formats the invocation can process.","example":"Kubernetes/YAML","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Defines a function invocation."},"InvocationCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Invocation":{"$ref":"#/components/schemas/Invocation"}}},"Link":{"required":["Slug","FromUnitID","ToUnitID"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FromUnitID":{"type":"string","description":"Unique identifier the Unit the Link initiates from. Links must be in the same space as the source unit.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"LinkID":{"type":"string","description":"Unique identifier for a Link.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ToSpaceID":{"type":"string","description":"Unique identifier the Space of the Unit the Link targets.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ToUnitID":{"type":"string","description":"Unique identifier the Unit the Link targets.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Link connects two config Units in a dependency / producer-consumer relationship.\nA Link indicates that config values Provided by the To Unit (the producer) may\nsatisfy config values Needed by the From Unit (the consumer), and should be attempted\nto be matched before values Provided by other Units in the Space (if within the same\nSpace). Links must be created in the same Space as the From Unit.\nThey also imply an ordering when Applied or Destroyed as a Set."},"LinkCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Link":{"$ref":"#/components/schemas/Link"}}},"Mutation":{"type":"object","properties":{"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FunctionInvocation":{"$ref":"#/components/schemas/FunctionInvocation"},"InvocationID":{"$ref":"#/components/schemas/UUID"},"LinkID":{"$ref":"#/components/schemas/UUID"},"MergeBaseRevisionNum":{"type":"integer","description":"MergeBaseRevisionNum is the sequence number of the revision preceding merged changes, if the change was due to a merge operation.","format":"int64","x-go-type-skip-optional-pointer":true},"MergeEndRevisionNum":{"type":"integer","description":"MergeEndRevisionNum is the sequence number of the revision ending merged changes, if the change was due to a merge operation.","format":"int64","x-go-type-skip-optional-pointer":true},"MergeSourceID":{"$ref":"#/components/schemas/UUID"},"MutationID":{"type":"string","description":"Unique identifier for a Mutation.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"MutationNum":{"type":"integer","description":"Sequence number for the Mutation.","format":"int64","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an Organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ProvidedPath":{"type":"string","description":"ProvidedPath is the path of the provided value used to satisfy a needed value if the change was made due to resolving a link.","x-go-type-skip-optional-pointer":true},"ProvidedResource":{"$ref":"#/components/schemas/ResourceInfo"},"RestoredRevisionNum":{"type":"integer","description":"Sequence number of the restored revision, if the change was due to a restore operation.","format":"int64","x-go-type-skip-optional-pointer":true},"RevisionID":{"type":"string","description":"Unique identifier of the corresponding Revision.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"RevisionNum":{"type":"integer","description":"Sequence number of the corresponding Revision.","format":"int64","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"TriggerID":{"$ref":"#/components/schemas/UUID"},"UnitID":{"type":"string","description":"Unique identifier for a Unit.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"UpgradedFromUpstreamRevisionNum":{"type":"integer","description":"Sequence number of the upstream revision the unit was upgraded from, if the change was due to an upgrade operation.","format":"int64","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Mutation is a single source of mutation for a Revision."},"MutationInfo":{"type":"object","properties":{"Index":{"type":"integer","description":"Function index or sequence number corresponding to the change","format":"int64","x-go-type-skip-optional-pointer":true},"MutationType":{"$ref":"#/components/schemas/MutationType"},"Predicate":{"type":"boolean","description":"Used to decide how to use the mututation","x-go-type-skip-optional-pointer":true},"Value":{"type":"string","description":"Removed configuration data if MutationType is Delete and otherwise the new data","x-go-type-skip-optional-pointer":true}}},"MutationMap":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/MutationInfo"}},"MutationType":{"enum":["Add","Delete","Update","Replace","None"],"type":"string"},"Organization":{"required":["Slug"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"BillingAccountID":{"type":"string","description":"Unique identifier for a billing account for the organization. Set to the BillingAccountID of the authenticated Organization.","format":"uuid","readOnly":true,"example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"ExternalID":{"type":"string","description":"Unique identifier for the External Identity Provider record matching this organization.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"The top-level container for an organization using ConfigHub."},"OrganizationMember":{"type":"object","properties":{"DisplayName":{"type":"string","description":"Friendly name for the organization member User.","x-go-type-skip-optional-pointer":true},"ExternalID":{"type":"string","description":"Unique identifier for the External Identity Provider record matching this User.","x-go-type-skip-optional-pointer":true},"ExternalOrganizationID":{"type":"string","description":"Unique identifier for the External Identity Provider record matching this organization.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ProfilePictureURL":{"type":"string","description":"The URL to get the profile avatar picture of the User.","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the organization member User.","x-go-type-skip-optional-pointer":true},"UserID":{"type":"string","description":"Unique identifier for the organization member User.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Username":{"type":"string","description":"Unique username for a User. Must be unique for all of ConfigHub.","x-go-type-skip-optional-pointer":true}},"description":"a User given membership on the Organization"},"QueuedOperation":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"BridgeWorkerID":{"type":"string","description":"BridgeWorkerID is the unique identifier of the bridge worker that will process this operation.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"Dependencies":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"Dependencies contains the list of operation IDs that this operation depends on. Operations will not be delivered until all dependencies are completed.","nullable":true,"x-go-type-skip-optional-pointer":true},"ExtraParams":{"type":"string","description":"ExtraParams contains additional parameters for the operation in string format.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"OrganizationID is the unique identifier of the organization this operation belongs to.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"QueuedOperationID":{"type":"string","description":"QueuedOperationID is the unique identifier for the queued operation.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"RevisionNum":{"type":"integer","description":"RevisionNum is the revision number this operation was performed on.","format":"int64","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"SpaceID is the unique identifier of the space of the unit this operation is performed on.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Status":{"enum":["Pending","Delivered","Progressing","Completed","Failed","Aborted","pending","delivered"],"type":"string","description":"Status indicates the current status of the queued operation. v2 statuses: Pending (waiting), Delivered (sent to worker), Progressing (being processed), Completed (success), Failed (error). v1 compatibility: 'pending' = Pending, 'delivered' = Completed (legacy 'delivered' meant work done).","x-go-type-skip-optional-pointer":true},"TargetID":{"type":"string","description":"TargetID is the unique identifier of the target this operation is directed to.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"UnitID is the unique identifier of the unit this operation is performed on.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control.\nThe value read must be sent in calls to Update.","format":"int64","x-go-type-skip-optional-pointer":true}},"description":"QueuedOperation is a record of an operation to be done by a bridge worker."},"ResourceInfo":{"type":"object","properties":{"ResourceCategory":{"type":"string","description":"Category of configuration element represented in the configuration data; Kubernetes and OpenTofu resources are of category Resource, and application configuration files are of category AppConfig","x-go-type-skip-optional-pointer":true},"ResourceName":{"type":"string","description":"Name of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form \u003cmetadata.namespace\u003e/\u003cmetadata.name\u003e; not all ToolchainTypes necessarily use '/' as a separator between any scope(s) and name or other client-chosen ID","x-go-type-skip-optional-pointer":true},"ResourceNameWithoutScope":{"type":"string","description":"Name of a resource in the system under management represented in the configuration data, without any uniquifying scope, such as Namespace, Project, Account, Region, etc.; Kubernetes resources are represented in the form \u003cmetadata.name\u003e","x-go-type-skip-optional-pointer":true},"ResourceType":{"type":"string","description":"Type of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form \u003capiVersion\u003e/\u003ckind\u003e (aka group-version-kind)","x-go-type-skip-optional-pointer":true}}},"ResourceInfoList":{"type":"array","items":{"$ref":"#/components/schemas/ResourceInfo"}},"ResourceMutation":{"type":"object","properties":{"Aliases":{"type":"object","additionalProperties":{"type":"object"},"description":"Names (with scopes, if any) used in current and prior revisions of this resource","x-go-type-skip-optional-pointer":true},"AliasesWithoutScopes":{"type":"object","additionalProperties":{"type":"object"},"description":"Names without scopes used in current and prior revisions of this resource","x-go-type-skip-optional-pointer":true},"PathMutationMap":{"$ref":"#/components/schemas/MutationMap"},"Resource":{"$ref":"#/components/schemas/ResourceInfo"},"ResourceMutationInfo":{"$ref":"#/components/schemas/MutationInfo"}}},"ResourceMutationList":{"type":"array","items":{"$ref":"#/components/schemas/ResourceMutation"},"nullable":true},"ResponseError":{"type":"object","properties":{"Details":{"type":"array","items":{"type":"string"},"description":"Additional context messages","x-go-type-skip-optional-pointer":true},"ErrorCategory":{"type":"string","description":"The type of error (e.g., validation, not-found)","x-go-type-skip-optional-pointer":true},"ErrorMetadata":{"$ref":"#/components/schemas/ErrorMetadata"},"Message":{"type":"string","description":"The primary error message","x-go-type-skip-optional-pointer":true},"Status":{"type":"integer","description":"HTTP status code","x-go-type-skip-optional-pointer":true},"Type":{"type":"string","description":"The type of error (e.g., validation, not-found)","x-go-type-skip-optional-pointer":true}}},"Revision":{"type":"object","properties":{"ApplyGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"A map of \"\u003ctrigger slug\u003e/\u003cfunction name\u003e\" to true of Triggers invoking validating functions that did not pass on the configuration data at this Revision.","x-go-type-skip-optional-pointer":true},"ApprovedBy":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"the users that have approved the latest version of the config data for the Unit.","x-go-type-skip-optional-pointer":true},"ChangeSetID":{"$ref":"#/components/schemas/UUID"},"ContentHash":{"type":"integer","description":"The CRC32 hash of this revision's data.","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"Data":{"type":"string","description":"The full configuration data for this unit at this revision.","format":"base64","x-go-type-skip-optional-pointer":true},"Description":{"type":"string","description":"User description of the change. It is copied from the LastChangeDescription field of the Unit at the time the change was made that created the Revision.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"LiveAt":{"type":"string","description":"Time at which the revision was applied, if it was applied. If not applied, the value is \"0001-01-01T00:00:00Z\".","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"MutationSources":{"$ref":"#/components/schemas/ResourceMutationList"},"OrganizationID":{"type":"string","description":"Unique identifier for an Organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"RevisionID":{"type":"string","description":"Unique identifier for a Revision.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"RevisionNum":{"type":"integer","description":"Sequence number for a Revision.","format":"int64","x-go-type-skip-optional-pointer":true},"Source":{"type":"string","description":"ConfigHub operation that created this revision.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Tags":{"type":"object","additionalProperties":{"type":"string"},"description":"A set (map) of TagIDs of any Tags applied to this Revision. The string values have no particular meaning for now.","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"Unique identifier for a Unit.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"UserAgent":{"type":"string","description":"User-Agent string if created by an API call. Optional.","x-go-type-skip-optional-pointer":true},"UserID":{"type":"string","description":"UserID if change was made by a user. Automated changes, such as by triggers and resolve, are currently made with the UserID \"00000000-0000-0000-0000-000000000000\".","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Revision is a historial view of a Config Unit."},"Space":{"required":["Slug"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true},"WhereTrigger":{"type":"string","description":"Filter expression to identify Triggers that should be invoked on Units within this Space. The specified string is an expression for the purpose of filtering\nthe list of Triggers returned. The expression syntax was inspired by SQL.\nIt supports conjunctions using `AND` of relational expressions of the form *attribute*\n*operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,\nas in the JSON encoding.\nStrings support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.\nString pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,\n`ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.\nString regex operators: `~` for regex matching, `~*` for case-insensitive regex,\n`!~` and `!~*` for regex not matching (case-sensitive and insensitive).\nIntegers support the following operators: `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `=`, `!=`, `IN`, `NOT IN`.\nUUIDs and boolean attributes support equality and inequality only.\nUUID and time literals must be quoted as string literals.\nString literals are quoted with single quotes, such as `'string'`.\nTime literals use the same form as when serialized as JSON,\nsuch as: `CreatedAt \u003e '2025-02-18T23:16:34'`.\nInteger and boolean literals are also supported for attributes of those types.\nArrays support the `?` operator to to match any element of the array,\nas in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.\nArrays can perform LEN() to check for length, as in `LEN(ApprovedBy) \u003e 0`.\nMap support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.\nThe `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,\nsuch as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.\nConjunctions are supported using the `AND` operator.\nAn example conjunction is:\n`CreatedAt \u003e= '2025-01-07' AND Slug = 'test' AND Labels.mykey = 'myvalue'`.\n\nSupported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, DeleteGates, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.\n\nCurrently other entities (e.g., Space.Slug) may not be referenced in the expression.\n\nThe whole string must be query-encoded.","x-go-type-skip-optional-pointer":true}},"description":"The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities."},"SpaceCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Space":{"$ref":"#/components/schemas/Space"}}},"StandardErrorResponse":{"type":"object","properties":{"Code":{"type":"string","description":"HTTP status code of the response.","x-go-type-skip-optional-pointer":true},"Message":{"type":"string","description":"Message returned with the response.","x-go-type-skip-optional-pointer":true}},"description":"Error response details."},"Tag":{"required":["Slug"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"ChangeSetID":{"$ref":"#/components/schemas/UUID"},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"TagID":{"type":"string","description":"TagID uniquely identifies a tag within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Defines a Tag that can be used to identify a set of Revisions across Units."},"TagCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Tag":{"$ref":"#/components/schemas/Tag"}}},"Target":{"required":["Slug","ToolchainType","ProviderType","BridgeWorkerID"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"BridgeWorkerID":{"type":"string","description":"Unique identifier for a Bridge Worker associated with the Target.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Parameters":{"type":"string","description":"Parameters contains toolchain-type and/or provider-type-specific parameters in JSON format.\n\nFor ProviderType: Kubernetes (ToolchainType: Kubernetes/YAML)\nThe Parameters object may contain the following fields:\n- \"KubeContext\" (string): The name of the Kubernetes context (from \"~/.kube/config\") to use. (Not typically needed if running in-cluster).\n- \"KubeNamespace\" (string, optional): The target Kubernetes namespace for applying or managing resources.\n- \"WaitTimeout\" (string): A duration string (e.g., \"5m\", \"2m30s\") specifying how long to wait for resources to reach a ready state. Defaults to \"2m0s\".\n\nFor ProviderType: FluxOCIWriter (ToolchainType: Kubernetes/YAML)\nThe Parameters object may contain the following fields:\n- \"Repository\" (string, required): The base OCI repository URL (e.g., \"oci://ghcr.io/my-org\"). The 'UnitSlug' (a system-provided identifier for the configuration unit) will be appended to this URL to form the full image path (e.g., \"oci://ghcr.io/my-org/\u003cUnitSlug\u003e\").\n- \"Tag\" (string, optional): Explicit OCI tag for the image. Confighub will automatically set the tag on each push using the Unit's current RevisionNum being applied. This will have 'rev' prefixed to the number, like 'rev42'. When Tag is populated, it can be used to explicitly set a value that you want Confighub to publish to the OCI in addition to the default RevisionNum tag. For example 'latest' or 'trunk'.\n- \"Provider\" (string, optional): Specifies the authentication provider for the OCI registry. Defaults to \"None\".\n    Possible values:\n    - \"None\": Uses local Docker configuration (e.g., from '~/.docker/config.json') or the system's credential keychain.\n    - \"Generic\": Uses generic OCI provider authentication.\n    - \"AWS\": Uses AWS ECR authentication.\n    - \"Azure\": Uses Azure CR authentication.\n    - \"GCP\": Uses Google CR/Artifact Registry authentication.\n- \"AllowDeletion\" (string, optional): A boolean string (\"true\" or \"false\") indicating if the worker is allowed to delete images from the repository. Defaults to \"false\".\n- \"KubernetesSecretName\" (string, optional): The name of a Kubernetes Secret containing Docker credentials. The secret should typically have a '.dockerconfigjson' key, or 'username' and 'password' keys.\n- \"KubernetesSecretNamespace\" (string, optional): The Kubernetes namespace where the \"KubernetesSecretName\" is located. If not specified, the secret is assumed to be in the same namespace as the ConfigHub worker.\n","x-go-type-skip-optional-pointer":true},"ProviderType":{"type":"string","description":"ProviderType specifies the cloud or infrastructure provider for this target, such as \"Kubernetes\" or \"AWS\".","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"TargetID":{"type":"string","description":"Unique identifier for a Target.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain supported by this Target. Possible values include \"Kubernetes/YAML\", \"OpenTofu/HCL\", \"AppConfig/Properties\".","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy)."},"TargetCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Target":{"$ref":"#/components/schemas/Target"}}},"TargetType2":{"type":"object","properties":{"Name":{"type":"string","description":"Used to set the Slug and DisplayName of the Target created in ConfigHub","x-go-type-skip-optional-pointer":true},"Params":{"type":"object","additionalProperties":{},"description":"Used to set the Parameters of the Target created in ConfigHub","x-go-type-skip-optional-pointer":true}}},"Trigger":{"required":["Slug","Event","ToolchainType"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"Arguments":{"type":"array","items":{"$ref":"#/components/schemas/FunctionArgument"},"description":"Function arguments","nullable":true,"x-go-type-skip-optional-pointer":true},"BridgeWorkerID":{"$ref":"#/components/schemas/UUID"},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"Disabled":{"type":"boolean","description":"Disabled indicates whether this trigger is currently disabled.\n\t\tWhen disabled, the trigger will not be executed even when matching events occur.","example":"false","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"Enforced":{"type":"boolean","description":"Enforced indicates whether this trigger cannot be overridden.\n\t\tEnforced triggers implement mandatory policies that cannot be bypassed.","example":"true","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Event":{"type":"string","description":"Event specifies the type of event that will activate this trigger. Valid values are Mutation and PostClone","x-go-type-skip-optional-pointer":true},"FunctionName":{"type":"string","description":"Function name","x-go-type-skip-optional-pointer":true},"InvocationID":{"$ref":"#/components/schemas/UUID"},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"ToolchainType":{"required":["true"],"type":"string","description":"ToolchainType specifies the type of toolchain this trigger works with.\n\t\tThis determines which configuration formats the trigger can process.","example":"Kubernetes/YAML","x-go-type-skip-optional-pointer":true},"TriggerID":{"type":"string","description":"TriggerID uniquely identifies a trigger within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Validating":{"type":"boolean","description":"Validating indicates whether this is a validating function (true) or not (false).\n\t\tWhen false, the function can be either mutating (modifying configuration) or readonly returning an AttributeValueList (extracting values without modification).\n\t\tValidating functions check configuration validity without modifying it.\n\t\tThis value is returned by ConfigHub based on the corresponding property of the specified function.","readOnly":true,"example":"true","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Defines an automated function invocation that executes in response to specific\nUnit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,\nautomated transformations, or other custom logic that should run when configuration\nchanges occur. Each Trigger is associated with a specific Space and can be configured\nto execute on events.\n\nTriggers can be either validating (checking configuration validity without modifying it)\nor mutating (making changes to the configuration). They can also be enforced (cannot be\noverridden) or disabled."},"TriggerCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Trigger":{"$ref":"#/components/schemas/Trigger"}}},"UUID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d"},"Unit":{"required":["Slug","ToolchainType"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"ApplyGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"A map of \"\u003ctrigger slug\u003e/\u003cfunction name\u003e\" to true of Triggers invoking validating functions that did not pass on the latest configuration data.","readOnly":true,"x-go-type-skip-optional-pointer":true},"ApprovedBy":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"The users that have approved the latest revision of the config data for the Unit.","nullable":true,"readOnly":true,"x-go-type-skip-optional-pointer":true},"BridgeWorkerID":{"$ref":"#/components/schemas/UUID"},"ChangeSetID":{"$ref":"#/components/schemas/UUID"},"ContentHash":{"type":"integer","description":"The CRC32 hash of the configuration data.","readOnly":true,"x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"Data":{"type":"string","description":"The full configuration data for this unit. The maximum size is 67108864 bytes.","format":"base64","x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DestroyGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block destroy operations.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FromLinkID":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"description":"IDs of Links originating from this Unit.","nullable":true,"readOnly":true,"x-go-type-skip-optional-pointer":true},"HeadMutationNum":{"type":"integer","description":"Sequence number the head Mutation.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"HeadRevisionNum":{"type":"integer","description":"Sequence number the head Revision.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"LastAppliedRevisionNum":{"type":"integer","description":"Sequence number the last Revision applied. 0 if no live revision.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"LastChangeDescription":{"type":"string","description":"LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.","x-go-type-skip-optional-pointer":true},"LiveRevisionNum":{"type":"integer","description":"Sequence number the last Revision applied once apply has completed. 0 if no live revision.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"LiveState":{"type":"string","description":"The current live state of the Unit as reported by the bridge worker associated with the Target attached to the Unit.","format":"base64","readOnly":true,"x-go-type-skip-optional-pointer":true},"MutationSources":{"$ref":"#/components/schemas/ResourceMutationList"},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Outputs":{"type":"string","description":"The outputs of the last successful apply of the Unit.","format":"base64","readOnly":true,"x-go-type-skip-optional-pointer":true},"PreviousLiveRevisionNum":{"type":"integer","description":"Sequence number the previous Revision applied. 0 if no live revision.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"TargetID":{"$ref":"#/components/schemas/UUID"},"ToolchainType":{"type":"string","description":"ToolchainType specifies the type of toolchain for this unit. Possible values include \"Kubernetes/YAML\", \"OpenTofu/HCL\", \"AppConfig/Properties\", \"ConfigHub/YAML\".","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"Unique identifier for a Unit.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"UpstreamOrganizationID":{"$ref":"#/components/schemas/UUID"},"UpstreamRevisionNum":{"type":"integer","description":"Sequence number for the Revision of the Unit this unit was cloned from, or 0. This is updated to the upstream Unit's head revision number when the Unit is upgraded.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"UpstreamSpaceID":{"$ref":"#/components/schemas/UUID"},"UpstreamUnitID":{"$ref":"#/components/schemas/UUID"},"Values":{"type":"object","additionalProperties":{"type":"string"},"description":"Map from \"\u003ctrigger slug\u003e/\u003cattribute name\u003e\" to the first output Value with that attribute name of the function invocation specified by the Trigger.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data\nof a single supported Toolchain Type (congifuration format). This blob is typically a text document\nthat contains a collection of Kubernetes or infrastructure resources, or an application configuration\nfile. Applying / deploying or destroying the configuration happens as a single *transaction*\nfrom ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by\nthe underlying configuration / deployment tool. The resources must belong to a single\ninfrastructure provider and the actuation mechanism must be able to resolve references and\nordering dependencies among the resources within the document. For example, if one resource\nneeds to be fully provisioned to provide input to another resource, then the actuation code is\nresponsible for handling this. Revisions store historical copies of the configuration data.\nConfiguration data can be restored from prior Revisions. Units can also be cloned to create\nnew variants of a configuration."},"UnitAction":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"BridgeWorkerID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"Dependencies":{"type":"array","items":{"$ref":"#/components/schemas/UUID"},"nullable":true,"x-go-type-skip-optional-pointer":true},"ExtraParams":{"type":"string","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"QueuedOperationID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"RevisionNum":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Status":{"type":"string","x-go-type-skip-optional-pointer":true},"TargetID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true}}},"UnitActionResponse":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/QueuedOperation"},"Error":{"$ref":"#/components/schemas/ResponseError"}}},"UnitCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Links":{"type":"array","items":{"$ref":"#/components/schemas/LinkCreateOrUpdateResponse"},"x-go-type-skip-optional-pointer":true},"Unit":{"$ref":"#/components/schemas/Unit"}}},"UnitEvent":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"BridgeWorkerID":{"$ref":"#/components/schemas/UUID"},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"Message":{"type":"string","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an Organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"QueuedOperationID":{"type":"string","description":"QueuedOperationID is the unique identifier for the corresponding queued operation.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Result":{"$ref":"#/components/schemas/ActionResultType"},"RevisionNum":{"type":"integer","format":"int64","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"StartedAt":{"type":"string","format":"date-time","example":"2006-01-02T15:04:05Z07:00","x-go-type-skip-optional-pointer":true},"Status":{"$ref":"#/components/schemas/ActionStatusType"},"TerminatedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"UnitEventID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UnitID":{"type":"string","description":"Unique identifier for a Unit.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks\nthe lifecycle of applying, destroying, or refreshing a Unit's configuration in the target\nlive system. The event captures the current status of the operation, any configuration\ndrift detected, and timing information about when the action started and completed.\nActions are atomic from ConfigHub's perspective but may involve multiple steps\nin the connected Bridge. The status and drift detection help track the health\nand consistency of the provisioned configuration compared to what is defined in the Unit."},"UnitExtended":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"ActionResult":{"$ref":"#/components/schemas/ActionResultType"},"ActionStartedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"ActionTerminatedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"ApprovedByUsers":{"type":"array","items":{"type":"string"},"nullable":true,"x-go-type-skip-optional-pointer":true},"Drift":{"type":"string","x-go-type-skip-optional-pointer":true},"FromLinks":{"type":"array","items":{"$ref":"#/components/schemas/Link"},"nullable":true,"x-go-type-skip-optional-pointer":true},"Status":{"type":"string","x-go-type-skip-optional-pointer":true},"ToLinks":{"type":"array","items":{"$ref":"#/components/schemas/Link"},"nullable":true,"x-go-type-skip-optional-pointer":true},"Unit":{"$ref":"#/components/schemas/Unit"}}},"UnitStatus":{"type":"object","properties":{"Action":{"$ref":"#/components/schemas/ActionType"},"ActionResult":{"$ref":"#/components/schemas/ActionResultType"},"ActionStartedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"ActionTerminatedAt":{"type":"string","format":"date-time","nullable":true,"x-go-type-skip-optional-pointer":true},"Drift":{"type":"string","x-go-type-skip-optional-pointer":true},"Status":{"type":"string","x-go-type-skip-optional-pointer":true}}},"UnitTagRequest":{"type":"object","properties":{"Revision":{"type":"string","description":"Which Unit revision to tag: 'HeadRevisionNum', 'LiveRevisionNum', 'LastAppliedRevisionNum', 'PreviousLiveRevisionNum', or 'Remove' to remove the tag from the unit","x-go-type-skip-optional-pointer":true},"TagID":{"type":"string","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true}}},"UnitTagResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"Message":{"type":"string","x-go-type-skip-optional-pointer":true}}},"User":{"required":["Slug"],"type":"object","properties":{"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"ExternalID":{"type":"string","description":"Unique identifier for the External Identity Provider record matching this User.","x-go-type-skip-optional-pointer":true},"ProfilePictureURL":{"type":"string","description":"The URL to get the profile avatar picture of the User.","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"UserID":{"type":"string","description":"Unique identifier for a User.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Username":{"type":"string","description":"Unique username for a User. Must be unique for all of Confighub.","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true}},"description":"a User in Confighub."},"View":{"required":["Slug","FilterID"],"type":"object","properties":{"Annotations":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Annotation key/value pairs for tools to attach information to entities.","x-go-type-skip-optional-pointer":true},"Columns":{"type":"array","items":{"$ref":"#/components/schemas/Column"},"description":"Columns to display, in order. (optional)","x-go-type-skip-optional-pointer":true},"CreatedAt":{"type":"string","description":"The timestamp when the entity was created in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"CursorID":{"type":"integer","description":"An auto-incrementing sequence number used for pagination.","format":"int64","readOnly":true,"x-go-type-skip-optional-pointer":true},"DeleteGates":{"type":"object","additionalProperties":{"type":"boolean"},"description":"An optional set of gates that, if any is present, will block deletion.","x-go-type-skip-optional-pointer":true},"DisplayName":{"type":"string","description":"Friendly name for the entity.","x-go-type-skip-optional-pointer":true},"EntityType":{"type":"string","description":"The type of entity.","readOnly":true,"x-go-type-skip-optional-pointer":true},"FilterID":{"type":"string","description":"FilterID identifies a filter. (required)","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"GroupBy":{"type":"string","description":"Column to group by (optional).","x-go-type-skip-optional-pointer":true},"Labels":{"type":"object","additionalProperties":{"type":"string"},"description":"An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.","x-go-type-skip-optional-pointer":true},"OrderBy":{"type":"string","description":"Column to sort by. (optional)","x-go-type-skip-optional-pointer":true},"OrderByDirection":{"type":"string","description":"Columnn sort order, ASC or DESC. Default is ASC. Only should be specified if OrderBy is specified. (optional)","x-go-type-skip-optional-pointer":true},"OrganizationID":{"type":"string","description":"Unique identifier for an organization.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"Slug":{"type":"string","description":"Unique URL-safe identifier for the entity.","x-go-type-skip-optional-pointer":true},"SpaceID":{"type":"string","description":"Unique identifier for a space.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true},"UpdatedAt":{"type":"string","description":"The timestamp when the entity was last updated in \"2023-01-01T12:00:00Z\" format.","format":"date-time","readOnly":true,"example":"2025-04-04T11:50:02.95102-07:00","x-go-type-skip-optional-pointer":true},"Version":{"type":"integer","description":"An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.","format":"int64","readOnly":false,"x-go-type-skip-optional-pointer":true},"ViewID":{"type":"string","description":"ViewID uniquely identifies a view within the system.","format":"uuid","example":"248df4b7-aa70-47b8-a036-33ac447e668d","x-go-type-skip-optional-pointer":true}},"description":"Defines an entity view."},"ViewCreateOrUpdateResponse":{"type":"object","properties":{"Error":{"$ref":"#/components/schemas/ResponseError"},"View":{"$ref":"#/components/schemas/View"}}},"WorkerInfo":{"type":"object","properties":{"BridgeWorkerInfo":{"$ref":"#/components/schemas/BridgeWorkerInfo"},"FunctionWorkerInfo":{"$ref":"#/components/schemas/FunctionWorkerInfo"}}}},"securitySchemes":{"bearerAuth":{"type":"http","scheme":"bearer","bearerFormat":"JWT","description":"Bearer authentication"}}}}
